diff -ruN a/cmake/CMakeLists.txt b/cmake/CMakeLists.txt
--- a/cmake/CMakeLists.txt	2025-11-05 15:55:49.426477000 +0100
+++ b/cmake/CMakeLists.txt	2025-11-05 16:02:26.122425000 +0100
@@ -3,11 +3,10 @@
 # CMake build system
 # This file is part of LAMMPS
 cmake_minimum_required(VERSION 3.16)
-########################################
-# initialize version variables with project command
-if(POLICY CMP0048)
-  cmake_policy(SET CMP0048 NEW)
+if(CMAKE_VERSION VERSION_LESS 3.20)
+  message(WARNING "LAMMPS is planning to require at least CMake version 3.20 by Summer 2025. Please upgrade!")
 endif()
+########################################
 # set policy to silence warnings about ignoring <PackageName>_ROOT but use it
 if(POLICY CMP0074)
   cmake_policy(SET CMP0074 NEW)
@@ -28,10 +27,7 @@
 
 ########################################
 
-project(lammps
-        DESCRIPTION "The LAMMPS Molecular Dynamics Simulator"
-        HOMEPAGE_URL "https://www.lammps.org"
-        LANGUAGES CXX C)
+project(lammps CXX)
 set(SOVERSION 0)
 get_property(BUILD_IS_MULTI_CONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
 
@@ -48,7 +44,6 @@
 set(LAMMPS_TOOLS_DIR      ${LAMMPS_DIR}/tools)
 set(LAMMPS_PYTHON_DIR     ${LAMMPS_DIR}/python)
 set(LAMMPS_POTENTIALS_DIR ${LAMMPS_DIR}/potentials)
-set(LAMMPS_THIRDPARTY_DIR ${LAMMPS_DIR}/third_party)
 
 set(LAMMPS_DOWNLOADS_URL "https://download.lammps.org" CACHE STRING "Base URL for LAMMPS downloads")
 set(LAMMPS_POTENTIALS_URL "${LAMMPS_DOWNLOADS_URL}/potentials")
@@ -103,42 +98,50 @@
 #####################################################################
 include(CheckIncludeFileCXX)
 
-# set required compiler flags and compiler/CPU arch specific optimizations
+# set required compiler flags, apply checks, and compiler/CPU arch specific optimizations
 if(CMAKE_CXX_COMPILER_ID STREQUAL "Intel")
+  # Intel classic compilers version 19 are broken and fail to compile the embedded fmtlib
+  if(CMAKE_CXX_COMPILER_VERSION VERSION_LESS 20.0)
+    message(ERROR "Intel classic compiler version ${CMAKE_CXX_COMPILER_VERSION} is too old")
+  endif()
+
   if(CMAKE_SYSTEM_NAME STREQUAL "Windows")
     if(CMAKE_CXX_COMPILER_ID STREQUAL "Intel")
       set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /Qrestrict")
     endif()
-    if(CMAKE_CXX_COMPILER_VERSION VERSION_EQUAL 17.3 OR CMAKE_CXX_COMPILER_VERSION VERSION_EQUAL 17.4)
-      set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /QxCOMMON-AVX512")
-    else()
-      set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /QxHost")
-    endif()
+    set(CMAKE_TUNE_DEFAULT "/QxHost")
   else()
     set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -restrict")
-    if(CMAKE_CXX_COMPILER_VERSION VERSION_EQUAL 17.3 OR CMAKE_CXX_COMPILER_VERSION VERSION_EQUAL 17.4)
-      set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -xCOMMON-AVX512")
-    else()
-      set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -xHost -fp-model fast=2 -no-prec-div -qoverride-limits -diag-disable=10441 -diag-disable=11074 -diag-disable=11076 -diag-disable=2196")
-    endif()
+    set(CMAKE_TUNE_DEFAULT "-xHost -fp-model fast=2 -no-prec-div -qoverride-limits -diag-disable=10441 -diag-disable=11074 -diag-disable=11076 -diag-disable=2196")
   endif()
 endif()
 
 # silence excessive warnings for new Intel Compilers
 if(CMAKE_CXX_COMPILER_ID STREQUAL "IntelLLVM")
-  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fp-model precise -Wno-tautological-constant-compare -Wno-unused-command-line-argument")
+  set(CMAKE_TUNE_DEFAULT "-fp-model precise -Wno-tautological-constant-compare -Wno-unused-command-line-argument")
 endif()
 
 # silence excessive warnings for PGI/NVHPC compilers
 if((CMAKE_CXX_COMPILER_ID STREQUAL "NVHPC") OR (CMAKE_CXX_COMPILER_ID STREQUAL "PGI"))
-  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Minform=severe")
+  set(CMAKE_TUNE_DEFAULT "-Minform=severe")
+endif()
+
+# this hack is required to compile fmt lib with CrayClang version 15.0.2
+# CrayClang is only directly recognized by version 3.28 and later
+if(CMAKE_VERSION VERSION_LESS 3.28)
+  get_filename_component(_exe "${CMAKE_CXX_COMPILER}" NAME)
+  if((CMAKE_CXX_COMPILER_ID STREQUAL "Clang") AND (_exe STREQUAL "crayCC"))
+    set(CMAKE_TUNE_DEFAULT "-DFMT_STATIC_THOUSANDS_SEPARATOR")
+  endif()
+else()
+  if(CMAKE_CXX_COMPILER_ID STREQUAL "CrayClang")
+    set(CMAKE_TUNE_DEFAULT "-DFMT_STATIC_THOUSANDS_SEPARATOR")
+  endif()
 endif()
 
 # silence nvcc warnings
-if((PKG_KOKKOS) AND (Kokkos_ENABLE_CUDA) AND NOT
-    ((CMAKE_CXX_COMPILER_ID STREQUAL "Clang") OR (CMAKE_CXX_COMPILER_ID STREQUAL "IntelLLVM")
-    OR (CMAKE_CXX_COMPILER_ID STREQUAL "XLClang") OR (CMAKE_CXX_COMPILER_ID STREQUAL "CrayClang")))
-  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Xcudafe --diag_suppress=unrecognized_pragma,--diag_suppress=128")
+if((PKG_KOKKOS) AND (Kokkos_ENABLE_CUDA) AND NOT (CMAKE_CXX_COMPILER_ID STREQUAL "Clang"))
+  set(CMAKE_TUNE_DEFAULT "${CMAKE_TUNE_DEFAULT}" "-Xcudafe --diag_suppress=unrecognized_pragma,--diag_suppress=128")
 endif()
 
 # we *require* C++11 without extensions but prefer C++17.
@@ -153,6 +156,9 @@
 if(CMAKE_CXX_STANDARD LESS 11)
   message(FATAL_ERROR "C++ standard must be set to at least 11")
 endif()
+if(CMAKE_CXX_STANDARD LESS 17)
+  message(WARNING "Selecting C++17 standard is preferred over C++${CMAKE_CXX_STANDARD}")
+endif()
 if(PKG_KOKKOS AND (CMAKE_CXX_STANDARD LESS 17))
   set(CMAKE_CXX_STANDARD 17)
 endif()
@@ -197,14 +203,10 @@
   set(CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS ON)
 endif()
 
-# do not include the (obsolete) MPI C++ bindings which makes for leaner object files
-# and avoids namespace conflicts. Put this early to increase its visbility.
-set(MPI_CXX_SKIP_MPICXX TRUE CACHE BOOL "Skip MPI C++ Bindings" FORCE)
-
 ########################################################################
 # User input options                                                   #
 ########################################################################
-# backward compatibility with older LAMMPS documentation
+# backward compatibility with CMake before 3.12 and older LAMMPS documentation
 if (PYTHON_EXECUTABLE)
   set(Python_EXECUTABLE "${PYTHON_EXECUTABLE}")
 endif()
@@ -220,12 +222,6 @@
     "   Setting Python interpreter to: ${Python_EXECUTABLE}")
 endif()
 
-find_package(Python COMPONENTS Interpreter QUIET)
-# NOTE: RHEL 8.0 and Ubuntu 18.04LTS ship with Python 3.6, Python 3.8 was EOL in 2024
-if(Python_VERSION VERSION_LESS 3.6)
-  message(FATAL_ERROR "LAMMPS requires Python 3.6 or later")
-endif()
-
 set(LAMMPS_MACHINE "" CACHE STRING "Suffix to append to lmp binary (WON'T enable any features automatically")
 mark_as_advanced(LAMMPS_MACHINE)
 if(LAMMPS_MACHINE)
@@ -238,6 +234,15 @@
 option(BUILD_TOOLS "Build and install LAMMPS tools (msi2lmp, binary2txt, chain)" OFF)
 option(BUILD_LAMMPS_GUI "Build and install the LAMMPS GUI" OFF)
 
+# Support using clang-tidy for C++ files with selected options
+set(ENABLE_CLANG_TIDY OFF CACHE BOOL "Include clang-tidy processing when compiling")
+if(ENABLE_CLANG_TIDY)
+  set(CMAKE_CXX_CLANG_TIDY "clang-tidy;-checks=-*,performance-trivially-destructible,performance-unnecessary-copy-initialization,performance-unnecessary-value-param,readability-redundant-control-flow,readability-redundant-declaration,readability-redundant-function-ptr-dereference,readability-redundant-member-init,readability-redundant-string-cstr,readability-redundant-string-init,readability-simplify-boolean-expr,readability-static-accessed-through-instance,readability-static-definition-in-anonymous-namespace,readability-qualified-auto,misc-unused-parameters,modernize-deprecated-ios-base-aliases,modernize-loop-convert,modernize-shrink-to-fit,modernize-use-auto,modernize-use-using,modernize-use-override,modernize-use-bool-literals,modernize-use-emplace,modernize-return-braced-init-list,modernize-use-equals-default,modernize-use-equals-delete,modernize-replace-random-shuffle,modernize-deprecated-headers,modernize-use-nullptr,modernize-use-noexcept,modernize-redundant-void-arg;-fix;-header-filter=.*,header-filter=library.h,header-filter=fmt/*.h" CACHE STRING "clang-tidy settings")
+else()
+  unset(CMAKE_CXX_CLANG_TIDY CACHE)
+endif()
+
+
 file(GLOB ALL_SOURCES CONFIGURE_DEPENDS ${LAMMPS_SOURCE_DIR}/[^.]*.cpp)
 file(GLOB MAIN_SOURCES CONFIGURE_DEPENDS ${LAMMPS_SOURCE_DIR}/main.cpp)
 list(REMOVE_ITEM ALL_SOURCES ${MAIN_SOURCES})
@@ -261,8 +266,8 @@
 
 set(STANDARD_PACKAGES
   ADIOS
+  ALLPKG
   AMOEBA
-  APIP
   ASPHERE
   ATC
   AWPMD
@@ -321,6 +326,7 @@
   MOLECULE
   MOLFILE
   NETCDF
+  OBMD
   ORIENT
   PERI
   PHONON
@@ -355,16 +361,27 @@
   option(PKG_${PKG} "Build ${PKG} Package" OFF)
 endforeach()
 
+set(DEPRECATED_PACKAGES AWPMD ATC POEMS)
+foreach(PKG ${DEPRECATED_PACKAGES})
+  if(PKG_${PKG})
+    message(WARNING
+          "The ${PKG} package will be removed from LAMMPS in Summer 2025 due to lack of "
+          "maintenance and use of code constructs that conflict with modern C++ compilers "
+          "and standards.  Please contact developers@lammps.org if you have any concerns "
+          "about this step.")
+  endif()
+endforeach()
+
 ######################################################
 # packages with special compiler needs or external libs
 ######################################################
 target_include_directories(lammps PUBLIC $<BUILD_INTERFACE:${LAMMPS_SOURCE_DIR}>)
-target_include_directories(lammps PUBLIC $<BUILD_INTERFACE:${LAMMPS_THIRDPARTY_DIR}>)
 
 if(PKG_ADIOS)
   # The search for ADIOS2 must come before MPI because
   # it includes its own MPI search with the latest FindMPI.cmake
   # script that defines the MPI::MPI_C target
+  enable_language(C)
   find_package(ADIOS2 REQUIRED)
   if(BUILD_MPI)
     if(NOT ADIOS2_HAVE_MPI)
@@ -379,18 +396,21 @@
 endif()
 
 if(NOT CMAKE_CROSSCOMPILING)
-  find_package(MPI QUIET COMPONENTS CXX)
+  find_package(MPI QUIET)
   option(BUILD_MPI "Build MPI version" ${MPI_FOUND})
 else()
   option(BUILD_MPI "Build MPI version" OFF)
 endif()
 
 if(BUILD_MPI)
+  # do not include the (obsolete) MPI C++ bindings which makes
+  # for leaner object files and avoids namespace conflicts
+  set(MPI_CXX_SKIP_MPICXX TRUE)
   # We use a non-standard procedure to cross-compile with MPI on Windows
   if((CMAKE_SYSTEM_NAME STREQUAL "Windows") AND CMAKE_CROSSCOMPILING)
     include(MPI4WIN)
   else()
-    find_package(MPI REQUIRED COMPONENTS CXX)
+    find_package(MPI REQUIRED)
     option(LAMMPS_LONGLONG_TO_LONG "Workaround if your system or MPI version does not recognize 'long long' data types" OFF)
     if(LAMMPS_LONGLONG_TO_LONG)
       target_compile_definitions(lammps PRIVATE -DLAMMPS_LONGLONG_TO_LONG)
@@ -404,8 +424,8 @@
   target_link_libraries(lammps PUBLIC mpi_stubs)
 endif()
 
-set(LAMMPS_SIZES "smallbig" CACHE STRING "LAMMPS integer sizes (smallbig: 64-bit #atoms #timesteps, bigbig: also 64-bit imageint, 64-bit atom ids)")
-set(LAMMPS_SIZES_VALUES smallbig bigbig)
+set(LAMMPS_SIZES "smallbig" CACHE STRING "LAMMPS integer sizes (smallsmall: all 32-bit, smallbig: 64-bit #atoms #timesteps, bigbig: also 64-bit imageint, 64-bit atom ids)")
+set(LAMMPS_SIZES_VALUES smallbig bigbig smallsmall)
 set_property(CACHE LAMMPS_SIZES PROPERTY STRINGS ${LAMMPS_SIZES_VALUES})
 validate_option(LAMMPS_SIZES LAMMPS_SIZES_VALUES)
 string(TOUPPER ${LAMMPS_SIZES} LAMMPS_SIZES)
@@ -423,25 +443,13 @@
   target_compile_definitions(lammps PRIVATE -DLAMMPS_MEMALIGN=${LAMMPS_MEMALIGN})
 endif()
 
-# this hack is required to compile fmt lib with CrayClang version 15.0.2
-# CrayClang is only directly recognized by CMake version 3.28 and later
-if(CMAKE_VERSION VERSION_LESS 3.28)
-  get_filename_component(_exe "${CMAKE_CXX_COMPILER}" NAME)
-  if((CMAKE_CXX_COMPILER_ID STREQUAL "Clang") AND (_exe STREQUAL "crayCC"))
-    target_compile_definitions(lammps PRIVATE -DFMT_STATIC_THOUSANDS_SEPARATOR)
-  endif()
-else()
-  if(CMAKE_CXX_COMPILER_ID STREQUAL "CrayClang")
-    target_compile_definitions(lammps PRIVATE -DFMT_STATIC_THOUSANDS_SEPARATOR)
-  endif()
-endif()
-
 # "hard" dependencies between packages resulting
 # in an error instead of skipping over files
 pkg_depends(ML-IAP ML-SNAP)
 pkg_depends(ATC MANYBODY)
 pkg_depends(LATBOLTZ MPI)
 pkg_depends(SCAFACOS MPI)
+pkg_depends(ALLPKG MPI)
 pkg_depends(AMOEBA KSPACE)
 pkg_depends(DIELECTRIC KSPACE)
 pkg_depends(DIELECTRIC EXTRA-PAIR)
@@ -451,7 +459,6 @@
 pkg_depends(EXTRA-MOLECULE MOLECULE)
 pkg_depends(MESONT MOLECULE)
 pkg_depends(RHEO BPM)
-pkg_depends(APIP ML-PACE)
 
 # detect if we may enable OpenMP support by default
 set(BUILD_OMP_DEFAULT OFF)
@@ -494,13 +501,13 @@
   if(CMAKE_VERSION VERSION_LESS 3.28)
     get_filename_component(_exe "${CMAKE_CXX_COMPILER}" NAME)
     if((CMAKE_CXX_COMPILER_ID STREQUAL "Clang") AND (_exe STREQUAL "crayCC"))
-      set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -fopenmp")
-      set(CMAKE_STATIC_LINKER_FLAGS "${CMAKE_STATIC_LINKER_FLAGS} -fopenmp")
+      set(CMAKE_SHARED_LINKER_FLAGS_${BTYPE} "${CMAKE_SHARED_LINKER_FLAGS_${BTYPE}} -fopenmp")
+      set(CMAKE_STATIC_LINKER_FLAGS_${BTYPE} "${CMAKE_STATIC_LINKER_FLAGS_${BTYPE}} -fopenmp")
     endif()
   else()
     if(CMAKE_CXX_COMPILER_ID STREQUAL "CrayClang")
-      set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -fopenmp")
-      set(CMAKE_STATIC_LINKER_FLAGS "${CMAKE_STATIC_LINKER_FLAGS} -fopenmp")
+      set(CMAKE_SHARED_LINKER_FLAGS_${BTYPE} "${CMAKE_SHARED_LINKER_FLAGS_${BTYPE}} -fopenmp")
+      set(CMAKE_STATIC_LINKER_FLAGS_${BTYPE} "${CMAKE_STATIC_LINKER_FLAGS_${BTYPE}} -fopenmp")
     endif()
   endif()
 endif()
@@ -518,6 +525,7 @@
 endif()
 
 if(PKG_ATC OR PKG_AWPMD OR PKG_ML-QUIP OR PKG_ML-POD OR PKG_ELECTRODE OR PKG_RHEO OR BUILD_TOOLS)
+  enable_language(C)
   if (NOT USE_INTERNAL_LINALG)
     find_package(LAPACK)
     find_package(BLAS)
@@ -591,7 +599,7 @@
 endif()
 
 foreach(PKG_WITH_INCL KSPACE PYTHON ML-IAP VORONOI COLVARS ML-HDNNP MDI MOLFILE NETCDF
-        PLUMED QMMM ML-QUIP SCAFACOS MACHDYN VTK KIM COMPRESS ML-PACE LEPTON EXTRA-COMMAND)
+        PLUMED QMMM ML-QUIP SCAFACOS ALLPKG MACHDYN VTK KIM COMPRESS ML-PACE LEPTON EXTRA-COMMAND)
   if(PKG_${PKG_WITH_INCL})
     include(Packages/${PKG_WITH_INCL})
   endif()
@@ -614,6 +622,10 @@
   add_subdirectory(${LAMMPS_SWIG_DIR} swig)
 endif()
 
+set(CMAKE_TUNE_FLAGS "${CMAKE_TUNE_DEFAULT}" CACHE STRING "Compiler and machine specific optimization flags (compilation only)")
+separate_arguments(CMAKE_TUNE_FLAGS)
+target_compile_options(lammps PRIVATE ${CMAKE_TUNE_FLAGS})
+target_compile_options(lmp PRIVATE ${CMAKE_TUNE_FLAGS})
 ########################################################################
 # Basic system tests (standard libraries, headers, functions, types)   #
 ########################################################################
@@ -918,7 +930,7 @@
 include(Testing)
 include(CodeCoverage)
 include(CodingStandard)
-find_package(ClangFormat 11.0 QUIET)
+find_package(ClangFormat 11.0)
 
 if(ClangFormat_FOUND)
   add_custom_target(format-src
diff -ruN a/src/OBMD/fix_obmd_merged.cpp b/src/OBMD/fix_obmd_merged.cpp
--- a/src/OBMD/fix_obmd_merged.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/src/OBMD/fix_obmd_merged.cpp	2025-11-05 16:03:26.316561710 +0100
@@ -0,0 +1,2204 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://lammps.sandia.gov/, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+
+   Attribution:
+   - Original code by Sandia Corporation.
+   - OBMD extension uses portions of code derived from evaporate and deposit fix style:
+   https://docs.lammps.org/fix_evaporate.html
+   https://docs.lammps.org/fix_deposit.html
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "fix_obmd_merged.h"
+
+#include "atom.h"
+#include "atom_vec.h"
+#include "comm.h"
+#include "compute.h"
+#include "domain.h"
+#include "error.h"
+#include "fix.h"
+#include "force.h"
+#include "group.h"
+#include "input.h"
+#include "lattice.h"
+#include "math_const.h"
+#include "math_extra.h"
+#include "memory.h"
+#include "modify.h"
+#include "molecule.h"
+#include "neighbor.h"
+#include "pair.h"
+#include "random_park.h"
+#include "region.h"
+#include "update.h"
+#include "variable.h"
+
+#include "pair_lj_cut_rf.h"
+
+#include <cmath>
+#include <cstring>
+#include <iostream>
+
+using namespace LAMMPS_NS;
+using namespace FixConst;
+using namespace MathConst;
+
+enum { ATOM, MOLECULE };
+enum { DIST_UNIFORM, DIST_GAUSSIAN };
+enum { NONE, CONSTANT, EQUAL };
+enum { EXCHATOM, EXCHMOL };    // exchmode
+enum { MOVEATOM, MOVEMOL };    // movemode
+
+#define EPSILON 1.0e-6
+
+/* ---------------------------------------------------------------------- */
+
+FixObmdMerged::FixObmdMerged(LAMMPS *lmp, int narg, char **arg) :
+    Fix(lmp, narg, arg), idregion(nullptr), idregion2(nullptr), idregion3(nullptr),
+    idregion4(nullptr), idregion5(nullptr), idregion6(nullptr), idrigid(nullptr), idshake(nullptr),
+    onemols(nullptr), molfrac(nullptr), coords(nullptr), imageflags(nullptr), fixrigid(nullptr),
+    fixshake(nullptr), random(nullptr), list(nullptr), mark(nullptr)
+{
+  if (narg < 14) error->all(FLERR, "Illegal fix obmd command (check # of arguments)");
+
+  restart_global = 1;
+  time_depend = 1;
+  size_vector = 1;
+
+  pxxstr = nullptr;
+  pxystr = nullptr;
+  pxzstr = nullptr;
+  dpstr = nullptr;       // pressure amplitude
+  freqstr = nullptr;     // frequency
+  alphastr = nullptr;    // alpha for feedback algorithm
+  taustr = nullptr;      // tau for feedback algorithm
+  nbufstr = nullptr;     // desired number of particles in the buffer
+
+  // other args
+  ntype = utils::inumeric(FLERR, arg[3], false, lmp);
+  nfreq = utils::inumeric(FLERR, arg[4], false, lmp);
+  seed = utils::inumeric(FLERR, arg[5], false, lmp);
+  if (seed <= 0) error->all(FLERR, "Illegal fix obmd command");
+
+  // OBMD settings
+  if (strstr(arg[6], "v_") == arg[6]) {
+    int n = strlen(&arg[6][2]) + 1;
+    pxxstr = new char[n];
+    strcpy(xstr, &arg[6][2]);
+  } else {
+    pxx = utils::numeric(FLERR, arg[6], false, lmp);
+    pxxstyle = CONSTANT;
+  }
+
+  if (strstr(arg[7], "v_") == arg[7]) {
+    int n = strlen(&arg[7][2]) + 1;
+    pxystr = new char[n];
+    strcpy(ystr, &arg[7][2]);
+  } else {
+    pxy = utils::numeric(FLERR, arg[7], false, lmp);
+    pxystyle = CONSTANT;
+  }
+
+  if (strstr(arg[8], "v_") == arg[8]) {
+    int n = strlen(&arg[8][2]) + 1;
+    pxzstr = new char[n];
+    strcpy(zstr, &arg[8][2]);
+  } else {
+    pxz = utils::numeric(FLERR, arg[8], false, lmp);
+    pxzstyle = CONSTANT;
+  }
+
+  if (strstr(arg[9], "v_") == arg[9]) {
+    int n = strlen(&arg[9][2]) + 1;
+    dpstr = new char[n];
+    strcpy(dpstr, &arg[9][2]);
+  } else {
+    dpxx = utils::numeric(FLERR, arg[9], false, lmp);
+    dpstyle = CONSTANT;
+  }
+
+  if (strstr(arg[10], "v_") == arg[10]) {
+    int n = strlen(&arg[10][2]) + 1;
+    freqstr = new char[n];
+    strcpy(freqstr, &arg[10][2]);
+  } else {
+    freq = utils::numeric(FLERR, arg[10], false, lmp);
+    freqstyle = CONSTANT;
+  }
+
+  if (strstr(arg[11], "v_") == arg[11]) {
+    int n = strlen(&arg[11][2]) + 1;
+    alphastr = new char[n];
+    strcpy(alphastr, &arg[11][2]);
+  } else {
+    alpha = utils::numeric(FLERR, arg[11], false, lmp);
+    alphastyle = CONSTANT;
+  }
+
+  if (strstr(arg[12], "v_") == arg[12]) {
+    int n = strlen(&arg[12][2]) + 1;
+    taustr = new char[n];
+    strcpy(taustr, &arg[12][2]);
+  } else {
+    tau = utils::numeric(FLERR, arg[12], false, lmp);
+    taustyle = CONSTANT;
+  }
+
+  if (strstr(arg[13], "v_") == arg[13]) {
+    int n = strlen(&arg[13][2]) + 1;
+    nbufstr = new char[n];
+    strcpy(nbufstr, &arg[13][2]);
+  } else {
+    nbuf = utils::numeric(FLERR, arg[13], false, lmp);
+    nbufstyle = CONSTANT;
+  }
+
+  // read options from end of input line
+  varflag = CONSTANT;
+  options(narg - 14, &arg[14]);
+
+  // error check on type
+  if (mode == ATOM && (ntype <= 0 || ntype > atom->ntypes))
+    error->all(FLERR, "Invalid atom type in fix obmd command");
+
+  // error checks on region and its extent being inside simulation box
+  if (!iregion || !iregion2) error->all(FLERR, "Must specify a region in fix obmd");
+  if (iregion->bboxflag == 0 || iregion2->bboxflag == 0)
+    error->all(FLERR, "Fix obmd region does not support a bounding box");
+  if (iregion->dynamic_check() || iregion2->dynamic_check())
+    error->all(FLERR, "Fix obmd region cannot be dynamic");
+
+  xlo = iregion->extent_xlo;
+  xhi = iregion->extent_xhi;
+  ylo = iregion->extent_ylo;
+  yhi = iregion->extent_yhi;
+  zlo = iregion->extent_zlo;
+  zhi = iregion->extent_zhi;
+
+  if (domain->triclinic == 0) {
+    if (xlo < domain->boxlo[0] || xhi > domain->boxhi[0] || ylo < domain->boxlo[1] ||
+        yhi > domain->boxhi[1] || zlo < domain->boxlo[2] || zhi > domain->boxhi[2])
+      error->all(FLERR, "Insertion region extends outside simulation box");
+  } else {
+    if (xlo < domain->boxlo_bound[0] || xhi > domain->boxhi_bound[0] ||
+        ylo < domain->boxlo_bound[1] || yhi > domain->boxhi_bound[1] ||
+        zlo < domain->boxlo_bound[2] || zhi > domain->boxhi_bound[2])
+      error->all(FLERR, "Insertion region extends outside simulation box");
+  }
+
+  // error check and further setup for mode = MOLECULE
+  if (atom->tag_enable == 0) error->all(FLERR, "Cannot use fix obmd unless atoms have IDs");
+
+  if (mode == MOLECULE) {
+    for (int i = 0; i < nmol; i++) {
+      if (onemols[i]->xflag == 0) error->all(FLERR, "Fix obmd molecule must have coordinates");
+      if (onemols[i]->typeflag == 0) error->all(FLERR, "Fix obmd molecule must have atom types");
+      if (ntype + onemols[i]->ntypes <= 0 || ntype + onemols[i]->ntypes > atom->ntypes)
+        error->all(FLERR, "Invalid atom type in fix obmd mol command");
+
+      if (atom->molecular == Atom::TEMPLATE && onemols != atom->avec->onemols)
+        error->all(FLERR,
+                   "Fix obmd molecule template ID must be same "
+                   "as atom_style template ID");
+      onemols[i]->check_attributes();
+
+      // fix obmd uses geoemetric center of molecule for insertion
+      onemols[i]->compute_center();
+    }
+  }
+
+  if (rigidflag && mode == ATOM) error->all(FLERR, "Cannot use fix obmd rigid and not molecule");
+  if (shakeflag && mode == ATOM) error->all(FLERR, "Cannot use fix obmd shake and not molecule");
+  if (rigidflag && shakeflag) error->all(FLERR, "Cannot use fix obmd rigid and shake");
+
+  // setup of coords and imageflags array
+  if (mode == ATOM)
+    natom_max = 1;
+  else {
+    natom_max = 0;
+    for (int i = 0; i < nmol; i++) natom_max = MAX(natom_max, onemols[i]->natoms);
+  }
+  memory->create(coords, natom_max, 3, "obmd:coords");
+  memory->create(imageflags, natom_max, "obmd:imageflags");
+
+  // setup scaling
+  double xscale, yscale, zscale;
+  if (scaleflag) {
+    xscale = domain->lattice->xlattice;
+    yscale = domain->lattice->ylattice;
+    zscale = domain->lattice->zlattice;
+  } else
+    xscale = yscale = zscale = 1.0;
+
+  // apply scaling to all input parameters with dist/vel units
+  if (domain->dimension == 2) {
+    lo *= yscale;
+    hi *= yscale;
+    rate *= yscale;
+  } else {
+    lo *= zscale;
+    hi *= zscale;
+    rate *= zscale;
+  }
+  deltasq *= xscale * xscale;
+  nearsq *= xscale * xscale;
+  vxlo *= xscale;
+  vxhi *= xscale;
+  vylo *= yscale;
+  vyhi *= yscale;
+  vzlo *= zscale;
+  vzhi *= zscale;
+  xmid *= xscale;
+  ymid *= yscale;
+  zmid *= zscale;
+  sigma *= xscale;    // same as in region sphere
+  tx *= xscale;
+  ty *= yscale;
+  tz *= zscale;
+
+  // find current max atom and molecule IDs if necessary
+  if (idnext) find_maxid();
+
+  // random number generator, same for all procs
+  // warm up the generator 30x to avoid correlations in first-particle
+  // positions if runs are repeated with consecutive seeds
+  random = new RanPark(lmp, seed);
+  for (int ii = 0; ii < 30; ii++) random->uniform();
+
+  // set up reneighboring
+  force_reneighbor = 1;
+  next_reneighbor = update->ntimestep + 1;
+  nfirst = next_reneighbor;
+  ninserted = 0;
+  ndeleted = 0;
+  nmax = 0;
+  list = nullptr;
+  mark = nullptr;
+}
+
+/* ---------------------------------------------------------------------- */
+
+FixObmdMerged::~FixObmdMerged()
+{
+  delete random;
+  delete[] molfrac;
+  delete[] idrigid;
+  delete[] idshake;
+  delete[] idregion;
+  delete[] idregion2;
+  delete[] idregion3;
+  delete[] idregion4;
+  delete[] idregion5;
+  delete[] idregion6;
+  memory->destroy(coords);
+  memory->destroy(imageflags);
+  memory->destroy(list);
+  memory->destroy(mark);
+}
+
+/* ---------------------------------------------------------------------- */
+
+int FixObmdMerged::setmask()
+{
+  int mask = 0;
+  mask |= PRE_EXCHANGE;
+  mask |= POST_FORCE;
+  return mask;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixObmdMerged::init()
+{
+
+  if (pxxstr) {
+    pxxvar = input->variable->find(pxxstr);
+    if (pxxvar < 0) error->all(FLERR, "Variable name for fix obmd does not exist");
+    if (input->variable->equalstyle(pxxvar))
+      pxxstyle = EQUAL;
+    else if (input->variable->atomstyle(pxxvar))
+      pxxstyle = ATOM;
+    else
+      error->all(FLERR, "Variable for fix obmd is invalid style");
+  }
+
+  if (pxystr) {
+    pxyvar = input->variable->find(pxystr);
+    if (pxyvar < 0) error->all(FLERR, "Variable name for fix obmd does not exist");
+    if (input->variable->equalstyle(pxyvar))
+      pxystyle = EQUAL;
+    else if (input->variable->atomstyle(pxyvar))
+      pxystyle = ATOM;
+    else
+      error->all(FLERR, "Variable for fix obmd is invalid style");
+  }
+
+  if (pxzstr) {
+    pxzvar = input->variable->find(pxzstr);
+    if (pxzvar < 0) error->all(FLERR, "Variable name for fix obmd does not exist");
+    if (input->variable->equalstyle(pxzvar))
+      pxzstyle = EQUAL;
+    else if (input->variable->atomstyle(pxzvar))
+      pxzstyle = ATOM;
+    else
+      error->all(FLERR, "Variable for fix obmd is invalid style");
+  }
+
+  if (dpstr) {
+    dpvar = input->variable->find(dpstr);
+    if (dpvar < 0) error->all(FLERR, "Variable {} for fix obmd does not exist", dpstr);
+    if (input->variable->equalstyle(dpvar))
+      dpstyle = EQUAL;
+    else if (input->variable->atomstyle(dpvar))
+      dpstyle = ATOM;
+    else
+      error->all(FLERR, "Variable {} for fix obmd is invalid", dpstr);
+  }
+
+  if (freqstr) {
+    freqvar = input->variable->find(freqstr);
+    if (freqvar < 0) error->all(FLERR, "Variable {} for fix obmd does not exist", freqstr);
+    if (input->variable->equalstyle(freqvar))
+      freqstyle = EQUAL;
+    else if (input->variable->atomstyle(freqvar))
+      freqstyle = ATOM;
+    else
+      error->all(FLERR, "Variable {} for fix obmd is invalid", freqstr);
+  }
+
+  if (alphastr) {
+    alphavar = input->variable->find(alphastr);
+    if (alphavar < 0) error->all(FLERR, "Variable {} for fix obmd does not exist", alphastr);
+    if (input->variable->equalstyle(alphavar))
+      alphastyle = EQUAL;
+    else if (input->variable->atomstyle(alphavar))
+      alphastyle = ATOM;
+    else
+      error->all(FLERR, "Variable {} for fix obmd is invalid", alphastr);
+  }
+
+  if (taustr) {
+    tauvar = input->variable->find(taustr);
+    if (tauvar < 0) error->all(FLERR, "Variable {} for fix obmd does not exist", taustr);
+    if (input->variable->equalstyle(tauvar))
+      taustyle = EQUAL;
+    else if (input->variable->atomstyle(tauvar))
+      taustyle = ATOM;
+    else
+      error->all(FLERR, "Variable {} for fix obmd is invalid", taustr);
+  }
+
+  if (nbufstr) {
+    nbufvar = input->variable->find(nbufstr);
+    if (nbufvar < 0) error->all(FLERR, "Variable {} for fix obmd does not exist", nbufstr);
+    if (input->variable->equalstyle(nbufvar))
+      nbufstyle = EQUAL;
+    else if (input->variable->atomstyle(nbufvar))
+      nbufstyle = ATOM;
+    else
+      error->all(FLERR, "Variable {} for fix obmd is invalid", nbufstr);
+  }
+
+  if (pxxstyle == ATOM || pxystyle == ATOM || pxzstyle == ATOM || dpstyle == ATOM ||
+      freqstyle == ATOM || alphastyle == ATOM || taustyle == ATOM || nbufstyle == ATOM)
+    varflag = ATOM;
+  else if (pxxstyle == EQUAL || pxystyle == EQUAL || pxzstyle == EQUAL || dpstyle == EQUAL ||
+           freqstyle == EQUAL || alphastyle == EQUAL || taustyle == EQUAL || nbufstyle == EQUAL)
+    varflag = EQUAL;
+  else
+    varflag = CONSTANT;
+
+  // get regions
+  iregion = domain->get_region_by_id(idregion);    // LEFT BUFFER
+  if (!iregion) error->all(FLERR, "Region ID for fix obmd does not exist");
+
+  iregion2 = domain->get_region_by_id(idregion2);    // RIGHT BUFFER
+  if (!iregion2) error->all(FLERR, "Region ID for fix obmd does not exist");
+
+  iregion3 = domain->get_region_by_id(idregion3);    // SHEAR FLOW LEFT
+  if (!iregion3) error->all(FLERR, "Region ID for fix obmd does not exist");
+
+  iregion4 = domain->get_region_by_id(idregion4);    // SHEAR FLOW RIGHT
+  if (!iregion4) error->all(FLERR, "Region ID for fix obmd does not exist");
+
+  iregion5 = domain->get_region_by_id(idregion5);    // INSERTION LEFT
+  if (!iregion5) error->all(FLERR, "Region ID for fix obmd does not exist");
+
+  iregion6 = domain->get_region_by_id(idregion6);    // INSERTION RIGHT
+  if (!iregion6) error->all(FLERR, "Region ID for fix obmd does not exist");
+
+  // check that no deletable atoms are in atom->firstgroup
+  // deleting such an atom would not leave firstgroup atoms first
+  if (atom->firstgroup >= 0) {
+    int *mask = atom->mask;
+    int nlocal = atom->nlocal;
+    int firstgroupbit = group->bitmask[atom->firstgroup];
+
+    int flag = 0;
+    for (int i = 0; i < nlocal; i++)
+      if ((mask[i] & groupbit) && (mask[i] && firstgroupbit)) flag = 1;
+
+    int flagall;
+    MPI_Allreduce(&flag, &flagall, 1, MPI_INT, MPI_SUM, world);
+
+    if (flagall) error->all(FLERR, "Cannot delete atoms in atom_modify first group");
+  }
+
+  // if MOLECULE not set, warn if any deletable atom has a mol ID
+  if (mode != MOLECULE && atom->molecule_flag) {
+    tagint *molecule = atom->molecule;
+    int *mask = atom->mask;
+    int nlocal = atom->nlocal;
+    int flag = 0;
+    for (int i = 0; i < nlocal; i++)
+      if (mask[i] & groupbit)
+        if (molecule[i]) flag = 1;
+    int flagall;
+    MPI_Allreduce(&flag, &flagall, 1, MPI_INT, MPI_SUM, world);
+    if (flagall && comm->me == 0)
+      error->warning(FLERR, "Fix obmd may delete atom with non-zero molecule ID");
+  }
+
+  if (mode == MOLECULE && atom->molecule_flag == 0)
+    error->all(FLERR, "Fix obmd molecule requires atom attribute molecule");
+
+  // if rigidflag defined, check for rigid/small fix
+  // its molecule template must be same as this one
+  fixrigid = nullptr;
+  if (rigidflag) {
+    int ifix = modify->find_fix(idrigid);
+    if (ifix < 0) error->all(FLERR, "Fix obmd rigid fix does not exist");
+    fixrigid = modify->fix[ifix];
+    int tmp;
+    if (onemols != (Molecule **) fixrigid->extract("onemol", tmp))
+      error->all(FLERR,
+                 "Fix obmd and fix rigid/small not using "
+                 "same molecule template ID");
+  }
+
+  // if shakeflag defined, check for SHAKE fix
+  // its molecule template must be same as this one
+  fixshake = nullptr;
+  if (shakeflag) {
+    fixshake = modify->get_fix_by_id(idshake);
+    if (!fixshake) error->all(FLERR, "Fix deposit shake fix ID {} does not exist", idshake);
+
+    int tmp;
+    if (onemols != (Molecule **) fixshake->extract("onemol", tmp))
+      error->all(FLERR,
+                 "Fix obmd and fix shake not using "
+                 "same molecule template ID");
+  }
+
+  // for finite size spherical particles:
+  // warn if near < 2 * maxrad of existing and inserted particles
+  // since may lead to overlaps
+  // if inserted molecule does not define diameters,
+  // use AtomVecSphere::create_atom() default radius = 0.5
+  if (atom->radius_flag) {
+    double *radius = atom->radius;
+    int nlocal = atom->nlocal;
+
+    double maxrad = 0.0;
+    for (int i = 0; i < nlocal; i++) maxrad = MAX(maxrad, radius[i]);
+
+    double maxradall;
+    MPI_Allreduce(&maxrad, &maxradall, 1, MPI_DOUBLE, MPI_MAX, world);
+
+    double maxradinsert = 0.0;
+    if (mode == MOLECULE) {
+      for (int i = 0; i < nmol; i++) {
+        if (onemols[i]->radiusflag)
+          maxradinsert = MAX(maxradinsert, onemols[i]->maxradius);
+        else
+          maxradinsert = MAX(maxradinsert, 0.5);
+      }
+    } else
+      maxradinsert = 0.5;
+
+    double separation = MAX(2.0 * maxradinsert, maxradall + maxradinsert);
+    if (sqrt(nearsq) < separation && comm->me == 0)
+      error->warning(FLERR,
+                     fmt::format("Fix obmd near setting < possible "
+                                 "overlap separation {}",
+                                 separation));
+  }
+}
+
+/* ----------------------------------------------------------------------
+   setup
+------------------------------------------------------------------------- */
+
+void FixObmdMerged::setup(int vflag)
+{
+  if (utils::strmatch(update->integrate_style, "^verlet")) post_force(vflag);
+}
+
+/* ----------------------------------------------------------------------
+   perform particle/molecule insertions/deletions
+------------------------------------------------------------------------- */
+void FixObmdMerged::pre_exchange()
+{
+  int cnt_left, cnt_right, stev_left, stev_right, i;
+  double ninsert_left, ninsert_right;
+  double masstotal_left, masstotal_right;
+
+  // calculate box dimensions
+  double lx = domain->boxhi[0] - domain->boxlo[0];
+  double ly = domain->boxhi[1] - domain->boxlo[1];
+  double lz = domain->boxhi[2] - domain->boxlo[2];
+
+  // fetch the curret value of momentum/energy flux if it is not CONSTANT
+  if (varflag != CONSTANT) {
+    if (pxxstyle == EQUAL) pxx = input->variable->compute_equal(pxxvar);
+    if (pxystyle == EQUAL) pxy = input->variable->compute_equal(pxyvar);
+    if (pxzstyle == EQUAL) pxz = input->variable->compute_equal(pxzvar);
+    if (dpstyle == EQUAL) dpxx = input->variable->compute_equal(dpvar);
+    if (freqstyle == EQUAL) freq = input->variable->compute_equal(freqvar);
+    if (alphastyle == EQUAL) alpha = input->variable->compute_equal(alphavar);
+    if (taustyle == EQUAL) tau = input->variable->compute_equal(tauvar);
+    if (nbufstyle == EQUAL) nbuf = input->variable->compute_equal(nbufvar);
+  }
+
+  MathExtra::zero3(vnewl);
+  MathExtra::zero3(vnewr);
+
+  // delete particles that cross the open boundaries after first half of velocity-Verlet algorithm
+  try_deleting(iregion, vnewl, vnewr);
+  try_deleting(iregion2, vnewl, vnewr);
+
+  // count number of particles in left/right buffer
+  cnt_left = group->count(igroup, iregion);
+  cnt_right = group->count(igroup, iregion2);
+
+  // calculate number of particles needed for insertion
+  ninsert_left = -static_cast<int>((static_cast<double>(cnt_left) / mol_len - alpha * nbuf) *
+                                   update->dt / tau);
+  ninsert_right = -static_cast<int>((static_cast<double>(cnt_right) / mol_len - alpha * nbuf) *
+                                    update->dt / tau);
+
+  // tries inserting ninsert_left/right particles into left/right buffer
+  try_inserting(iregion5, ninsert_left, vnewl, vnewr);
+  try_inserting(iregion6, ninsert_right, vnewl, vnewr);
+
+  // deletes again, just in case part of newly inserted molecule is not inside box
+  try_deleting(iregion, vnewl, vnewr);
+  try_deleting(iregion2, vnewl, vnewr);
+
+  // calculates total mass in left/right buffer
+  masstotal_left = group->mass(igroup, iregion);
+  masstotal_right = group->mass(igroup, iregion2);
+
+  // sum \& distribute
+  MPI_Allreduce(vnewl, vnewl_all, 3, MPI_DOUBLE, MPI_SUM, world);
+  MPI_Allreduce(vnewr, vnewr_all, 3, MPI_DOUBLE, MPI_SUM, world);
+
+  // area of the buffer - ROI interface
+  double area = ly * lz;
+
+  simulation_time += update->dt;
+  double factor = pxx + dpxx * sin(2.0 * MY_PI * freq * simulation_time);
+
+  // calculates momentum forces on the left buffer
+  // substracting momentum of deleted particles
+  MathExtra::zero3(momentumForce_left);
+  momentumForce_left[0] = vnewl_all[0] / (update->dt) + factor * area;
+  momentumForce_left[1] = vnewl_all[1] / (update->dt);
+  momentumForce_left[2] = vnewl_all[2] / (update->dt);
+  shearForce_left[0] = 0.0;
+  shearForce_left[1] = pxy * area;
+  shearForce_left[2] = pxz * area;
+
+  // calculates momentum forces on the right buffer
+  MathExtra::zero3(momentumForce_right);
+  momentumForce_right[0] = vnewr_all[0] / (update->dt) - pxx * area;    // constant normal load
+  momentumForce_right[1] = vnewr_all[1] / (update->dt);
+  momentumForce_right[2] = vnewr_all[2] / (update->dt);
+  shearForce_right[0] = 0.0;
+  shearForce_right[1] = -pxy * area;
+  shearForce_right[2] = -pxz * area;
+
+  next_reneighbor += nfreq;
+}
+
+/* ----------------------------------------------------------------------
+   maxtag_all = current max atom ID for all atoms
+   maxmol_all = current max molecule ID for all atoms
+------------------------------------------------------------------------- */
+void FixObmdMerged::try_deleting(Region *region, double *vnewl, double *vnewr)
+{
+
+  int i, j, m, iwhichglobal, iwhichlocal;
+  int ndel, ndeltopo[4];
+
+  // grow list and mark arrays if necessary
+  if (atom->nmax > nmax) {
+    memory->destroy(list);
+    memory->destroy(mark);
+    nmax = atom->nmax;
+    memory->create(list, nmax, "obmd:list");
+    memory->create(mark, nmax, "obmd:mark");
+  }
+
+  region->prematch();
+
+  double **x = atom->x;
+  double **vel = atom->v;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  int nlocal = atom->nlocal;
+  double boxl = domain->boxlo[0];
+  double boxh = domain->boxhi[0];
+  double *mass = atom->mass;
+  int *type = atom->type;
+  double fusher[3];
+
+  int ncount = 0;
+  for (i = 0; i < nlocal; i++) {
+    if (x[i][0] < boxl || x[i][0] > boxh) {
+      std::cout << "Deleting x[i][0] = " << x[i][0] << " i = " << i << " type[i] = " << type[i]
+                << " global id = " << atom->tag[i] << std::endl;
+      list[ncount++] = i;
+    }
+  }
+
+  int nall, nbefore;
+  MPI_Allreduce(&ncount, &nall, 1, MPI_INT, MPI_SUM, world);
+  MPI_Scan(&ncount, &nbefore, 1, MPI_INT, MPI_SUM, world);
+  nbefore -= ncount;
+
+  ndel = 0;
+  for (i = 0; i < nlocal; i++) mark[i] = 0;
+
+  // atomic deletions
+  // choose atoms randomly across all procs and mark them for deletion
+  // shrink eligible list as my atoms get marked
+  // keep ndel,ncount,nall,nbefore current after each atom deletion
+  if (mode == ATOM) {
+    while (nall) {
+      iwhichglobal = static_cast<int>(nall * random->uniform());
+      if (iwhichglobal < nbefore)
+        nbefore--;
+      else if (iwhichglobal < nbefore + ncount) {
+        iwhichlocal = iwhichglobal - nbefore;
+        mark[list[iwhichlocal]] = 1;
+        list[iwhichlocal] = list[ncount - 1];
+        ncount--;
+      }
+      ndel++;
+      nall--;
+    }
+
+    // molecule deletions
+    // choose one atom in one molecule randomly across all procs
+    // bcast mol ID and delete all atoms in that molecule on any proc
+    // update deletion count by total # of atoms in molecule
+    // shrink list of eligible candidates as any of my atoms get marked
+    // keep ndel,ndeltopo,ncount,nall,nbefore current after each mol deletion
+  } else {
+    int me, proc, iatom, ndelone, ndelall, index;
+    tagint imolecule;
+    tagint *molecule = atom->molecule;
+    int *molindex = atom->molindex;
+    int *molatom = atom->molatom;
+    int molecular = atom->molecular;
+    Molecule **onemols = atom->avec->onemols;
+
+    ndeltopo[0] = ndeltopo[1] = ndeltopo[2] = ndeltopo[3] = 0;
+
+    while (nall) {
+      // pick an iatom,imolecule on proc me to delete
+      iwhichglobal = static_cast<int>(nall * random->uniform());
+      if (iwhichglobal >= nbefore && iwhichglobal < nbefore + ncount) {
+        iwhichlocal = iwhichglobal - nbefore;
+        iatom = list[iwhichlocal];
+        imolecule = molecule[iatom];
+        me = comm->me;
+      } else
+        me = -1;
+
+      // bcast mol ID to delete all atoms from
+      // if mol ID > 0, delete any atom in molecule and decrement counters
+      // if mol ID == 0, delete single iatom
+      // logic with ndeltopo is to count # of deleted bonds,angles,etc
+      // for atom->molecular = Atom::MOLECULAR, do this for each deleted atom in molecule
+      // for atom->molecular = Atom::TEMPLATE, use Molecule counts for just 1st atom in mol
+      MPI_Allreduce(&me, &proc, 1, MPI_INT, MPI_MAX, world);
+      MPI_Bcast(&imolecule, 1, MPI_LMP_TAGINT, proc, world);
+      ndelone = 0;
+      for (i = 0; i < nlocal; i++) {
+        if (imolecule && molecule[i] == imolecule) {
+          mark[i] = 1;
+          ndelone++;
+
+          if (molecular == Atom::MOLECULAR) {
+            if (atom->avec->bonds_allow) {
+              if (force->newton_bond)
+                ndeltopo[0] += atom->num_bond[i];
+              else {
+                for (j = 0; j < atom->num_bond[i]; j++) {
+                  if (tag[i] < atom->bond_atom[i][j]) ndeltopo[0]++;
+                }
+              }
+            }
+            if (atom->avec->angles_allow) {
+              if (force->newton_bond)
+                ndeltopo[1] += atom->num_angle[i];
+              else {
+                for (j = 0; j < atom->num_angle[i]; j++) {
+                  m = atom->map(atom->angle_atom2[i][j]);
+                  if (m >= 0 && m < nlocal) ndeltopo[1]++;
+                }
+              }
+            }
+            if (atom->avec->dihedrals_allow) {
+              if (force->newton_bond)
+                ndeltopo[2] += atom->num_dihedral[i];
+              else {
+                for (j = 0; j < atom->num_dihedral[i]; j++) {
+                  m = atom->map(atom->dihedral_atom2[i][j]);
+                  if (m >= 0 && m < nlocal) ndeltopo[2]++;
+                }
+              }
+            }
+            if (atom->avec->impropers_allow) {
+              if (force->newton_bond)
+                ndeltopo[3] += atom->num_improper[i];
+              else {
+                for (j = 0; j < atom->num_improper[i]; j++) {
+                  m = atom->map(atom->improper_atom2[i][j]);
+                  if (m >= 0 && m < nlocal) ndeltopo[3]++;
+                }
+              }
+            }
+
+          } else if (molecular == Atom::TEMPLATE) {
+            if (molatom[i] == 0) {
+              index = molindex[i];
+              ndeltopo[0] += onemols[index]->nbonds;
+              ndeltopo[1] += onemols[index]->nangles;
+              ndeltopo[2] += onemols[index]->ndihedrals;
+              ndeltopo[3] += onemols[index]->nimpropers;
+            }
+          }
+
+        } else if (me == proc && i == iatom) {
+          mark[i] = 1;
+          ndelone++;
+        }
+      }
+
+      // remove any atoms marked for deletion from my eligible list
+      i = 0;
+      while (i < ncount) {
+        if (mark[list[i]]) {
+          list[i] = list[ncount - 1];
+          ncount--;
+        } else
+          i++;
+      }
+
+      // update ndel,ncount,nall,nbefore
+      // ndelall is total atoms deleted on this iteration
+      // ncount is already correct, so resum to get nall and nbefore
+      MPI_Allreduce(&ndelone, &ndelall, 1, MPI_INT, MPI_SUM, world);
+      ndel += ndelall;
+      MPI_Allreduce(&ncount, &nall, 1, MPI_INT, MPI_SUM, world);
+      MPI_Scan(&ncount, &nbefore, 1, MPI_INT, MPI_SUM, world);
+      nbefore -= ncount;
+    }
+  }
+
+  // delete my marked atoms
+  // loop in reverse order to avoid copying marked atoms
+  AtomVec *avec = atom->avec;
+
+  for (i = nlocal - 1; i >= 0; i--) {
+    if (mark[i]) {
+      if (x[i][0] < 0.5 * (boxh + boxl)) {
+        vnewl[0] += mass[type[i]] * vel[i][0];
+        vnewl[1] += mass[type[i]] * vel[i][1];
+        vnewl[2] += mass[type[i]] * vel[i][2];
+      } else {
+        vnewr[0] += mass[type[i]] * vel[i][0];
+        vnewr[1] += mass[type[i]] * vel[i][1];
+        vnewr[2] += mass[type[i]] * vel[i][2];
+      }
+      avec->copy(atom->nlocal - 1, i, 1);
+      atom->nlocal--;
+    }
+  }
+
+  // reset global natoms and bonds, angles, etc
+  // if global map exists, reset it now instead of waiting for comm
+  // since deleting atoms messes up ghosts
+  atom->natoms -= ndel;
+
+  if (mode == MOLECULE) {
+    int all[4];
+    MPI_Allreduce(ndeltopo, all, 4, MPI_INT, MPI_SUM, world);
+    atom->nbonds -= all[0];
+    atom->nangles -= all[1];
+    atom->ndihedrals -= all[2];
+    atom->nimpropers -= all[3];
+  }
+
+  if (ndel && (atom->map_style != Atom::MAP_NONE)) {
+    atom->nghost = 0;
+    atom->map_init();
+    atom->map_set();
+  }
+
+  // statistics
+  ndeleted += ndel;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixObmdMerged::try_inserting(Region *iregion_var, int stev, double *vnewl, double *vnewr)
+{
+  int i, m, n, nlocalprev, imol, natom, flag, flagall, me, sum_all, ninsert;
+  double coord[3], lamda[3], delx, dely, delz, rsq;
+  double r[3], vnew[3], rotmat[3][3], quat[4];
+  double *newcoord;
+  double entmp, mtmp;
+  double *sublo, *subhi;
+  int iter;
+
+  double offset = 0.0;
+  if (rateflag) offset = (update->ntimestep - nfirst) * update->dt * rate;
+
+  double *mass = atom->mass;
+  int dimension = domain->dimension;
+
+  double boxl = domain->boxlo[0];
+  double boxh = domain->boxhi[0];
+
+  xlo = iregion_var->extent_xlo;
+  xhi = iregion_var->extent_xhi;
+  ylo = iregion_var->extent_ylo;
+  yhi = iregion_var->extent_yhi;
+  zlo = iregion_var->extent_zlo;
+  zhi = iregion_var->extent_zhi;
+
+  if (domain->triclinic == 0) {
+    sublo = domain->sublo;
+    subhi = domain->subhi;
+  } else {
+    sublo = domain->sublo_lamda;
+    subhi = domain->subhi_lamda;
+  }
+
+  // clear ghost count (and atom map) and any ghost bonus data
+  // internal to AtomVec
+  // same logic as beginning of Comm::exchange()
+  // do it now b/c inserting atoms will overwrite ghost atoms
+  if (atom->map_style != Atom::MAP_NONE) atom->map_clear();
+  atom->nghost = 0;
+  atom->avec->clear_bonus();
+
+  if (!idnext) find_maxid();    // idnext is set to zero
+
+  if (stev > 0) {
+    for (ninsert = 0; ninsert != stev; ninsert++) {
+      int success = 0;
+      int attempt = 0;
+
+      while (attempt < maxattempt) {
+        attempt++;
+
+        // choose random position for new particle within region
+        if (distflag == DIST_UNIFORM) {
+          do {
+            coord[0] = xlo + random->uniform() * (xhi - xlo);
+            coord[1] = ylo + random->uniform() * (yhi - ylo);
+            coord[2] = zlo + random->uniform() * (zhi - zlo);
+          } while (iregion_var->match(coord[0], coord[1], coord[2]) == 0);
+        } else if (distflag == DIST_GAUSSIAN) {
+          do {
+            coord[0] = xmid + random->gaussian() * sigma;
+            coord[1] = ymid + random->gaussian() * sigma;
+            coord[2] = zmid + random->gaussian() * sigma;
+          } while (iregion_var->match(coord[0], coord[1], coord[2]) == 0);
+        } else
+          error->all(FLERR, "Unknown particle distribution in fix obmd");
+
+        // adjust vertical coord by offset
+        if (dimension == 2)
+          coord[1] += offset;
+        else
+          coord[2] += offset;
+
+        // if global, reset vertical coord to be lo-hi above highest atom
+        // if local, reset vertical coord to be lo-hi above highest "nearby" atom
+        // local computation computes lateral distance between 2 particles w/ PBC
+        // when done, have final coord of atom or center pt of molecule
+        if (globalflag || localflag) {
+          int dim;
+          double max, maxall, delx, dely, delz, rsq;
+
+          if (dimension == 2) {
+            dim = 1;
+            max = domain->boxlo[1];
+          } else {
+            dim = 2;
+            max = domain->boxlo[2];
+          }
+
+          double **x = atom->x;
+          int nlocal = atom->nlocal;
+          for (i = 0; i < nlocal; i++) {
+            if (localflag) {
+              delx = coord[0] - x[i][0];
+              dely = coord[1] - x[i][1];
+              delz = 0.0;
+              domain->minimum_image(FLERR, delx, dely, delz);
+              if (dimension == 2)
+                rsq = delx * delx;
+              else
+                rsq = delx * delx + dely * dely;
+              if (rsq > deltasq) continue;
+            }
+            if (x[i][dim] > max) max = x[i][dim];
+          }
+
+          MPI_Allreduce(&max, &maxall, 1, MPI_DOUBLE, MPI_MAX, world);
+          if (dimension == 2)
+            coord[1] = maxall + lo + random->uniform() * (hi - lo);
+          else
+            coord[2] = maxall + lo + random->uniform() * (hi - lo);
+        }
+
+        // coords = coords of all atoms
+        // for molecule, perform random rotation around center pt
+        // apply PBC so final coords are inside box
+        // also modify image flags due to PBC
+        if (mode == ATOM) {
+          natom = 1;
+          coords[0][0] = coord[0];
+          coords[0][1] = coord[1];
+          coords[0][2] = coord[2];
+          imageflags[0] = ((imageint) IMGMAX << IMG2BITS) | ((imageint) IMGMAX << IMGBITS) | IMGMAX;
+        } else {
+
+          double rng = random->uniform();
+          imol = 0;
+          while (rng > molfrac[imol])
+            imol++;    // it chooses imol randomly out of all defined mymols
+          natom = onemols[imol]->natoms;
+          if (dimension == 3) {
+            if (orientflag) {
+              r[0] = rx;
+              r[1] = ry;
+              r[2] = rz;
+            } else {
+              r[0] = random->uniform() - 0.5;
+              r[1] = random->uniform() - 0.5;
+              r[2] = random->uniform() - 0.5;
+            }
+          } else {
+            r[0] = r[1] = 0.0;
+            r[2] = 1.0;
+          }
+          double theta = random->uniform() * MY_2PI;
+          MathExtra::norm3(r);                             // unit vector
+          MathExtra::axisangle_to_quat(r, theta, quat);    // quaternion
+          MathExtra::quat_to_mat(quat, rotmat);            // rotmat
+          for (i = 0; i < natom; i++) {
+            MathExtra::matvec(rotmat, onemols[imol]->dx[i], coords[i]);
+            coords[i][0] += coord[0];
+            coords[i][1] += coord[1];
+            coords[i][2] += coord[2];
+            imageflags[i] =
+                ((imageint) IMGMAX << IMG2BITS) | ((imageint) IMGMAX << IMGBITS) | IMGMAX;
+            domain->remap(coords[i], imageflags[i]);
+          }
+        }
+
+        // check distance between any existing atom and any inserted atom
+        // if less than near, try again
+        // use minimum_image() to account for PBC
+        double **x = atom->x;
+        int nlocal = atom->nlocal;
+        flag = 0;
+        if (nearflag) {
+          for (m = 0; m < natom; m++) {
+            for (i = 0; i < nlocal; i++) {
+              delx = coords[m][0] - x[i][0];
+              dely = coords[m][1] - x[i][1];
+              delz = coords[m][2] - x[i][2];
+              domain->minimum_image(FLERR, delx, dely, delz);
+              rsq = delx * delx + dely * dely + delz * delz;
+              if (rsq < nearsq) {
+                if (comm->me == 0)
+                  std::cout << "NEAR denies in attempt No. " << attempt << "." << std::endl;
+                flag = 1;
+              }
+            }
+          }
+        } else if (usherflag) {
+          me = -1;
+          entmp = usher(iregion_var, coords, etarget, natom, imol, iter);
+          if (entmp < etarget + EPSILON) {
+            if (comm->me == 0)
+              std::cout << "USHER accepts at E = " << entmp << " in attempt No. " << attempt
+                        << " with " << iter << " iterations" << std::endl;
+          } else {
+            if (comm->me == 0)
+              std::cout << "USHER denies at E = " << entmp << " at attempt No. " << attempt
+                        << std::endl;
+            flag = 1;
+          }
+        }
+
+        MPI_Allreduce(&flag, &flagall, 1, MPI_INT, MPI_MAX, world);
+        if (flagall) continue;
+
+        if (nearflag) { entmp = near_energy(iregion_var, coords, natom, imol); }
+
+        // proceed with insertion
+        nlocalprev = atom->nlocal;
+
+        // choose random velocity for new particle
+        // for now instering with zero velocity
+        // used for every atom in molecule
+        vnew[0] = 0.0;
+        vnew[1] = 0.0;
+        vnew[2] = 0.0;
+
+        // if target specified, change velocity vector accordingly
+        if (targetflag) {
+          double vel = sqrt(vnew[0] * vnew[0] + vnew[1] * vnew[1] + vnew[2] * vnew[2]);
+          delx = tx - coord[0];
+          dely = ty - coord[1];
+          delz = tz - coord[2];
+          double rsq = delx * delx + dely * dely + delz * delz;
+          if (rsq > 0.0) {
+            double rinv = sqrt(1.0 / rsq);
+            vnew[0] = delx * rinv * vel;
+            vnew[1] = dely * rinv * vel;
+            vnew[2] = delz * rinv * vel;
+          }
+        }
+
+        // this loop first just checks if an entire molecule can be inserted
+        sum_all = check_mol_proc(coords, newcoord, lamda, sublo, subhi, dimension, natom, me);
+
+        if (sum_all != natom) {
+          if (comm->me == 0)
+            std::cout << "Can not insert particle/molecule at timestep = " << update->ntimestep
+                      << " me = " << me << std::endl;
+          continue;
+        }
+
+        // happens rarely, e.g. if usher moves the atom/molecule outside of the (open) boundaries
+        int check;
+        check = check_mol_region(iregion_var, coords, natom);
+        if (check == 1) continue;
+
+        // check if new atoms are in my sub-box or above it if I am highest proc
+        // if so, add atom to my list via create_atom()
+        // initialize additional info about the atoms
+        // set group mask to "all" plus fix group
+        for (m = 0; m < natom; m++) {
+          if (domain->triclinic) {
+            domain->x2lamda(coords[m], lamda);
+            newcoord = lamda;
+          } else
+            newcoord = coords[m];
+          flag = check_proc(coords, newcoord, sublo, subhi, dimension);
+          if (flag) {
+            if (mode == ATOM) {
+              mtmp = mass[ntype];
+              atom->avec->create_atom(ntype, coords[m]);
+            } else {
+              mtmp = mtot;
+              atom->avec->create_atom(ntype + onemols[imol]->type[m], coords[m]);
+            }
+            n = atom->nlocal - 1;
+            atom->tag[n] = maxtag_all + m + 1;
+
+            if (mode == MOLECULE) {
+              if (atom->molecule_flag) {
+                if (onemols[imol]->moleculeflag) {
+                  atom->molecule[n] = maxmol_all + onemols[imol]->molecule[m];
+                } else {
+                  atom->molecule[n] = maxmol_all + 1;
+                }
+              }
+              if (atom->molecular == Atom::TEMPLATE) {
+                atom->molindex[n] = 0;
+                atom->molatom[n] = m;
+              }
+            }
+
+            atom->mask[n] = 1 | groupbit;
+            atom->image[n] = imageflags[m];
+            atom->v[n][0] = vnew[0];
+            atom->v[n][1] = vnew[1];
+            atom->v[n][2] = vnew[2];
+
+            if (mode == MOLECULE) {
+              onemols[imol]->quat_external = quat;
+              atom->add_molecule_atom(onemols[imol], m, n, maxtag_all);
+            }
+            modify->create_attribute(n);
+          }
+        }
+
+        // FixRigidSmall::set_molecule stores rigid body attributes
+        // coord is new position of geometric center of mol, not COM
+        // FixShake::set_molecule stores shake info for molecule
+        if (mode == MOLECULE) {
+          if (rigidflag)
+            fixrigid->set_molecule(nlocalprev, maxtag_all, imol, coord, vnew, quat);
+          else if (shakeflag)
+            fixshake->set_molecule(nlocalprev, maxtag_all, imol, coord, vnew, quat);
+        }
+
+        success = 1;
+        break;
+      }
+
+      if (!success && comm->me == 0)
+        error->warning(FLERR, "Particle/molecule insertion was unsuccessful");
+
+      // reset global natoms,nbonds,etc
+      // increment maxtag_all and maxmol_all if necessary
+      // if global map exists, reset it now instead of waiting for comm
+      // since other pre-exchange fixes may use it
+      // invoke map_init() b/c atom count has grown
+      if (success) {
+        if (coords[0][0] < 0.5 * (boxh + boxl)) {
+          vnewl[0] +=
+              0.0;    // add zero as you insert with zero velocity (if some velocity will be chosen, change this accordingly)
+          vnewl[1] +=
+              0.0;    // add zero as you insert with zero velocity (if some velocity will be chosen, change this accordingly)
+          vnewl[2] +=
+              0.0;    // add zero as you insert with zero velocity (if some velocity will be chosen, change this accordingly)
+        } else {
+          vnewr[0] +=
+              0.0;    // add zero as you insert with zero velocity (if some velocity will be chosen, change this accordingly)
+          vnewr[1] +=
+              0.0;    // add zero as you insert with zero velocity (if some velocity will be chosen, change this accordingly)
+          vnewr[2] +=
+              0.0;    // add zero as you insert with zero velocity	(if some velocity will be chosen, change this accordingly)
+        }
+        atom->natoms += natom;
+
+        if (atom->natoms < 0) error->all(FLERR, "Too many total atoms");
+        if (mode == MOLECULE) {
+          atom->nbonds += onemols[imol]->nbonds;
+          atom->nangles += onemols[imol]->nangles;
+          atom->ndihedrals += onemols[imol]->ndihedrals;
+          atom->nimpropers += onemols[imol]->nimpropers;
+        }
+        maxtag_all += natom;
+        if (maxtag_all >= MAXTAGINT) error->all(FLERR, "New atom IDs exceed maximum allowed ID");
+        if (mode == MOLECULE && atom->molecule_flag) {
+          if (onemols[imol]->moleculeflag) {
+            maxmol_all += onemols[imol]->nmolecules;
+          } else {
+            maxmol_all++;
+          }
+        }
+      }
+
+      // rebuild atom map
+      if (atom->map_style != Atom::MAP_NONE) {
+        if (success) atom->map_init();
+        atom->map_set();
+      }
+    }
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixObmdMerged::post_force(int vflag)
+{
+  if (update->ntimestep % nevery) { return; }
+
+  // parallel forces
+  reg_force(vflag, iregion, momentumForce_left, step_parallel);
+  reg_force(vflag, iregion2, momentumForce_right, step_parallel);
+
+  // tangential forces
+  reg_force_perp(vflag, iregion3, shearForce_left, step_perp);
+  reg_force_perp(vflag, iregion4, shearForce_right, step_perp);
+}
+
+/* ---------------------------------------------------------------------- */
+
+double FixObmdMerged::g_par_global_charged(Region *region, int step)
+{
+
+  // using molecule's center-of-mass
+  if (region) region->prematch();
+
+  int nlocal = atom->nlocal;
+  tagint *molecule = atom->molecule;
+  double *mass = atom->mass;
+  int *type = atom->type;
+  double **x = atom->x;
+  int imol;
+  int *tag = atom->tag;
+  double **f = atom->f;
+
+  double upper_x = domain->boxhi[0];    // upper
+  double lower_x = domain->boxlo[0];    // lower
+
+  // init for distribution function
+  double g_par_all = 0.0;
+  double g_par_all_tmp = 0.0;
+
+  // for now only smooth transition -> ADD for step = 1
+  double carg;
+  if (!step) {
+    for (int i = 0; i < nlocal; i++) {
+
+      // mass of a particle
+      double mass_temp = mass[type[i]];
+
+      // (looping over nlocals) check if in prescribed region, continue if not
+      if (region && !region->match(x[i][0], x[i][1], x[i][2])) continue;
+
+      // if here ... molecule in buffer
+      if (x[i][0] < lower_x + buffer_size) {                        // LEFT BUFFER
+        if (x[i][0] < (lower_x + (1.0 - g_fac) * buffer_size)) {    // only mass
+          g_par_all += mass_temp;
+        } else {    // sigmoidal mass
+          carg = 1.0 / g_fac * MY_PI * (x[i][0] - buffer_size - lower_x) / (-buffer_size) -
+              MY_PI;    // OK (also for -lower_x)
+          g_par_all += 0.5 * (1.0 + cos(carg)) * mass_temp;
+        }
+      }
+      if (x[i][0] > upper_x - buffer_size) {    // RIGHT BUFFER
+        if (x[i][0] > (upper_x - (1.0 - g_fac) * buffer_size)) {
+          g_par_all += mass_temp;
+        } else {
+          carg = 1.0 / g_fac * MY_PI * (x[i][0] - upper_x + buffer_size) /
+              (buffer_size) -MY_PI;    // OK (also for -lower_x)
+          g_par_all += 0.5 * (1.0 + cos(carg)) * mass_temp;
+        }
+      }
+      // OTHER IS NOT OF MY INTEREST ... ROI
+    }
+  } else {
+    error->all(FLERR, "For now implemented only for !step");
+  }
+
+  // sum and distribute
+  MPI_Allreduce(&g_par_all, &g_par_all_tmp, 1, MPI_DOUBLE, MPI_SUM, world);
+
+  return g_par_all_tmp;
+}
+
+/* ---------------------------------------------------------------------- */
+
+double FixObmdMerged::g_par_local_charged(double mass, Region *region, double xv, int step)
+{
+  // using molecule's center-of-mass
+  double upper_x = domain->boxhi[0];    // upper
+  double lower_x = domain->boxlo[0];    // lower
+
+  double carg = 0.0;
+  if (!step) {
+    if (xv < lower_x + buffer_size) {    // LEFT BUFFER
+      if (xv < (lower_x + (1.0 - g_fac) * buffer_size)) {
+        return mass;
+      } else {    // sigmodial mass
+        carg = 1.0 / g_fac * MY_PI * (xv - buffer_size - lower_x) / (-buffer_size) - MY_PI;
+        return 0.5 * (1.0 + cos(carg)) * mass;
+      }
+    }
+    if (xv > upper_x - buffer_size) {    // RIGHT BUFFER
+      if (xv > (upper_x - (1.0 - g_fac) * buffer_size)) {
+        return mass;
+      } else {    // sigmodial mass
+        carg = 1.0 / g_fac * MY_PI * (xv - upper_x + buffer_size) / (buffer_size) -MY_PI;
+        return 0.5 * (1.0 + cos(carg)) * mass;
+      }
+    }
+    // OTHER IS NOT OF MY INTEREST ... ROI
+  } else {
+    error->all(FLERR, "For now implemented only for !step");
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+double FixObmdMerged::g_perp_global_charged(Region *iregion_var, int step)
+{
+  if (iregion_var) iregion_var->prematch();
+
+  int nlocal = atom->nlocal;
+  tagint *molecule = atom->molecule;
+  double *mass = atom->mass;
+  int *type = atom->type;
+  double **x = atom->x;
+  int imol;
+  int *tag = atom->tag;
+  double **f = atom->f;
+
+  double upper_x = domain->boxhi[0];
+  double lower_x = domain->boxlo[0];
+
+  double g_perp_all = 0.0;
+  double g_perp_all_tmp = 0.0;
+
+  if (step) {
+    for (int i = 0; i < nlocal; i++) {
+      // mass of a particle
+      double mass_temp = mass[type[i]];
+
+      if (iregion_var && !iregion_var->match(x[i][0], x[i][1], x[i][2])) continue;
+      g_perp_all += mass_temp;
+    }
+  } else {
+    error->all(FLERR, "For now implemented only for step");
+  }
+
+  // sum and distribute
+  MPI_Allreduce(&g_perp_all, &g_perp_all_tmp, 1, MPI_DOUBLE, MPI_SUM, world);
+
+  return g_perp_all_tmp;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixObmdMerged::reg_force(int vflag, Region *region, double *momentumForce, int step)
+{
+  if (region) region->prematch();
+  v_init(vflag);
+
+  double **x = atom->x;
+  double **f = atom->f;
+  double *mass = atom->mass;
+  int *mask = atom->mask;
+  imageint *image = atom->image;
+  double v[6];
+  int nlocal = atom->nlocal;
+  double mass_tmp;
+  int *type = atom->type;
+  double gtmp = g_par_global_charged(region, step);
+  double gloctmp;
+  double unwrap[3];
+  double xval, yval, zval;
+
+  // create test_force to check obmd
+  double test_force[3];
+  test_force[0] = test_force[1] = test_force[2] = 0.0;
+  double sestevek = 0.0;
+
+  double test_force_all[3];
+  test_force_all[0] = test_force_all[2] = test_force_all[3] = 0.0;
+
+  int allnu = 0;
+
+  for (int i = 0; i < nlocal; i++) {
+    if (region && !region->match(x[i][0], x[i][1], x[i][2])) continue;
+    domain->unmap(x[i], image[i], unwrap);
+    mass_tmp = mass[type[i]];
+    if (mode == MOLECULE) mass_tmp = mtot;
+
+    gloctmp = g_par_local_charged(mass[type[i]], region, x[i][0], step);
+
+    xval = momentumForce[0] * gloctmp / gtmp;
+    yval = momentumForce[1] * gloctmp / gtmp;
+    zval = momentumForce[2] * gloctmp / gtmp;
+
+    f[i][0] += xval;
+    f[i][1] += yval;
+    f[i][2] += zval;
+
+    test_force[0] += momentumForce[0] * gloctmp / gtmp;
+    test_force[1] += momentumForce[1] * gloctmp / gtmp;
+    test_force[2] += momentumForce[2] * gloctmp / gtmp;
+
+    sestevek += gloctmp;
+
+    if (evflag) {
+      v[0] = xval * unwrap[0];
+      v[1] = yval * unwrap[1];
+      v[2] = zval * unwrap[2];
+      v[3] = xval * unwrap[1];
+      v[4] = xval * unwrap[2];
+      v[5] = yval * unwrap[2];
+      v_tally(i, v);
+    }
+  }
+
+  MPI_Allreduce(test_force, test_force_all, 3, MPI_DOUBLE, MPI_SUM, world);
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixObmdMerged::reg_force_perp(int vflag, Region *region, double *shearForce, int step)
+{
+  if (region) region->prematch();
+  v_init(vflag);
+
+  double **x = atom->x;
+  double **f = atom->f;
+  double *mass = atom->mass;
+  int *mask = atom->mask;
+  imageint *image = atom->image;
+  double v[6];
+  int nlocal = atom->nlocal;
+  foriginal[0] = foriginal[1] = foriginal[2] = foriginal[3] = 0.0;
+  force_flag = 0;
+  int *type = atom->type;
+  double gtmp = g_perp_global_charged(region, step);
+  double mass_tmp, gloctmp;
+  double unwrap[3];
+  double xval, yval, zval;
+
+  // create test_force to check obmd
+  double test_perp_force[3];
+  test_perp_force[0] = test_perp_force[1] = test_perp_force[2] = 0.0;
+  double sestevek_perp = 0.0;
+
+  double test_perp_force_all[3];
+  test_perp_force_all[0] = test_perp_force_all[1] = test_perp_force_all[2] = 0.0;
+
+  for (int i = 0; i < nlocal; i++) {
+    if (region && !region->match(x[i][0], x[i][1], x[i][2])) continue;
+    domain->unmap(x[i], image[i], unwrap);
+    mass_tmp = mass[type[i]];
+    if (mode == MOLECULE) mass_tmp = mtot;
+
+    gloctmp = mass[type[i]];
+
+    xval = shearForce[0] * gloctmp / gtmp;
+    yval = shearForce[1] * gloctmp / gtmp;
+    zval = shearForce[2] * gloctmp / gtmp;
+
+    f[i][0] += xval;
+    f[i][1] += yval;
+    f[i][2] += zval;
+
+    test_perp_force[0] += shearForce[0] * gloctmp / gtmp;
+    test_perp_force[1] += shearForce[1] * gloctmp / gtmp;
+    test_perp_force[2] += shearForce[2] * gloctmp / gtmp;
+
+    sestevek_perp += gloctmp;
+
+    if (evflag) {
+      v[0] = xval * unwrap[0];
+      v[1] = yval * unwrap[1];
+      v[2] = zval * unwrap[2];
+      v[3] = xval * unwrap[1];
+      v[4] = xval * unwrap[2];
+      v[5] = yval * unwrap[2];
+      v_tally(i, v);
+    }
+  }
+
+  MPI_Allreduce(test_perp_force, test_perp_force_all, 3, MPI_DOUBLE, MPI_SUM, world);
+}
+
+/* ---------------------------------------------------------------------- */
+
+double FixObmdMerged::usher(Region *iregion_var, double **coords, double etarget, int natom,
+                            int imol, int &iter)
+{
+
+  int i, m, type_temp;
+  double entmp, torqabs, dtheta, ds, fabs;
+  double quat[4], rotmat[3][3], fusher_tmp[3], fusher_all[3], xcom[3];
+  double torq[3], torq_all[3], torq_tmp[3], coords_tmp[3];
+
+  double entmp_all;
+  MathExtra::zero3(fusher_tmp);
+
+  i = 0;
+  while (i < nattempt) {
+
+    entmp = 0.0;
+    type_temp = ntype;
+    MathExtra::zero3(fusher);
+    MathExtra::zero3(torq);
+
+    if (chargeflag) {
+      mol_center_of_mass(natom, imol, coords, xcom);
+    } else {
+      center_of_mass(natom, coords, xcom);
+    }
+
+    for (m = 0; m < natom; m++) {
+      if (mode == MOLECULE) type_temp = ntype + onemols[imol]->type[m];
+
+      if (chargeflag) {
+        entmp +=
+            energy_atomistic_obmd(iregion_var, onemols[imol]->q[m], type_temp, coords[m], fusher);
+      } else {
+        entmp += energy(1, type_temp, coords[m],
+                        fusher);    // i - does not matter, itype inserted, coords[m], fusher
+      }
+
+      // torque
+      MathExtra::copy3(fusher, fusher_tmp);
+      calc_torque(natom, coords, xcom, fusher_tmp, torq_tmp);
+      MathExtra::add3(torq, torq_tmp, torq);
+    }
+
+    MPI_Allreduce(fusher, fusher_all, 3, MPI_DOUBLE, MPI_SUM, world);
+    MPI_Allreduce(&entmp, &entmp_all, 1, MPI_DOUBLE, MPI_SUM, world);
+    MPI_Allreduce(&torq, &torq_all, 3, MPI_DOUBLE, MPI_SUM, world);
+
+    if (entmp_all < etarget + EPSILON)
+      break;
+    else if (entmp_all > uovlp) {
+      fabs = sqrt(fusher_all[0] * fusher_all[0] + fusher_all[1] * fusher_all[1] +
+                  fusher_all[2] * fusher_all[2]);
+      if (fabs < EPSILON) continue;
+      ds = dsovlp - pow(4 * eps / entmp_all, 1.0 / 12.0);
+
+      // loop over atoms of molecule
+      for (m = 0; m < natom; m++) {
+        coords[m][0] += fusher_all[0] / fabs * ds;
+        coords[m][1] += fusher_all[1] / fabs * ds;
+        coords[m][2] += fusher_all[2] / fabs * ds;
+      }
+      int check = check_mol_region(iregion_var, coords, natom);
+      if (check == 1) break;    // exit
+
+    } else {
+      fabs = sqrt(fusher_all[0] * fusher_all[0] + fusher_all[1] * fusher_all[1] +
+                  fusher_all[2] * fusher_all[2]);
+      if (fabs < EPSILON) continue;
+      ds = std::min((entmp_all - etarget) / fabs, ds0);
+
+      if (mode == MOLECULE) {
+        torqabs =
+            sqrt(torq_all[0] * torq_all[0] + torq_all[1] * torq_all[1] + torq_all[2] * torq_all[2]);
+        dtheta = std::min((entmp_all - etarget) / torqabs, dtheta0);
+        MathExtra::norm3(torq_all);
+        MathExtra::axisangle_to_quat(torq_all, dtheta, quat);
+        MathExtra::quat_to_mat(quat, rotmat);
+      }
+
+      for (m = 0; m < natom; m++) {
+        coords[m][0] += fusher_all[0] / fabs * ds;
+        coords[m][1] += fusher_all[1] / fabs * ds;
+        coords[m][2] += fusher_all[2] / fabs * ds;
+
+        if (mode == MOLECULE) {
+          MathExtra::matvec(rotmat, coords[m], coords_tmp);
+          MathExtra::copy3(coords_tmp, coords[m]);
+        }
+      }
+      int check = check_mol_region(iregion_var, coords, natom);
+      if (check == 1) break;    // exit
+    }
+    i += 1;
+  }
+  iter = i;
+  entmp = entmp_all;
+
+  return entmp;
+}
+
+/* ---------------------------------------------------------------------- */
+
+double FixObmdMerged::near_energy(Region *iregion_var, double **coords, int natom, int imol)
+{
+  double entmp, entmp_all;
+  double fusher[3];
+  int m, type_temp;
+  entmp = 0.0;
+  type_temp = ntype;
+
+  for (m = 0; m < natom; m++) {
+    if (mode == MOLECULE) type_temp = ntype + onemols[imol]->type[m];
+
+    if (chargeflag) {
+      entmp +=
+          energy_atomistic_obmd(iregion_var, onemols[imol]->q[m], type_temp, coords[m], fusher);
+    } else {
+      entmp += energy(1, type_temp, coords[m], fusher);
+    }
+  }
+
+  MPI_Allreduce(&entmp, &entmp_all, 1, MPI_DOUBLE, MPI_SUM, world);
+  return entmp_all;
+}
+
+/* ---------------------------------------------------------------------- */
+
+int FixObmdMerged::check_proc(double **coords, double *newcoord, double *sublo, double *subhi,
+                              int dimension)
+{
+  int flag = 0;
+  if (newcoord[0] >= sublo[0] && newcoord[0] < subhi[0] && newcoord[1] >= sublo[1] &&
+      newcoord[1] < subhi[1] && newcoord[2] >= sublo[2] && newcoord[2] < subhi[2])
+    flag = 1;
+  else if (dimension == 3 && newcoord[2] >= domain->boxhi[2]) {    /// for 3D
+    if (comm->layout != Comm::LAYOUT_TILED) {
+      if (comm->myloc[2] == comm->procgrid[2] - 1 && newcoord[0] >= sublo[0] &&
+          newcoord[0] < subhi[0] && newcoord[1] >= sublo[1] && newcoord[1] < subhi[1])
+        flag = 1;
+    } else {
+      if (comm->mysplit[2][1] == 1.0 && newcoord[0] >= sublo[0] && newcoord[0] < subhi[0] &&
+          newcoord[1] >= sublo[1] && newcoord[1] < subhi[1])
+        flag = 1;
+    }
+  } else if (dimension == 2 && newcoord[1] >= domain->boxhi[1]) {    /// for 2D
+    if (comm->layout != Comm::LAYOUT_TILED) {
+      if (comm->myloc[1] == comm->procgrid[1] - 1 && newcoord[0] >= sublo[0] &&
+          newcoord[0] < subhi[0])
+        flag = 1;
+    } else {
+      if (comm->mysplit[1][1] == 1.0 && newcoord[0] >= sublo[0] && newcoord[0] < subhi[0]) flag = 1;
+    }
+  }
+  return flag;
+}
+
+/* ---------------------------------------------------------------------- */
+
+int FixObmdMerged::check_mol_proc(double **coords, double *newcoord, double *lamda, double *sublo,
+                                  double *subhi, int dimension, int natom, int &me)
+{
+  int m;
+  int sum_all_tmp = 0;
+  int sum_all_tmpall, flag;
+
+  for (m = 0; m < natom; m++) {
+    if (domain->triclinic) {
+      domain->x2lamda(coords[m], lamda);
+      newcoord = lamda;
+    } else
+      newcoord = coords[m];
+    flag = check_proc(coords, newcoord, sublo, subhi, dimension);
+    sum_all_tmp += flag;
+  }
+  MPI_Allreduce(&sum_all_tmp, &sum_all_tmpall, 1, MPI_INT, MPI_SUM, world);
+  if (sum_all_tmp == natom) me = comm->me;
+
+  return sum_all_tmpall;
+}
+
+/* ---------------------------------------------------------------------- */
+
+int FixObmdMerged::check_mol_region(Region *region, double **coords, int natom)
+{
+  int m, flag, flagall;
+  flag = 0;
+  for (m = 0; m < natom; m++) {
+    if (region && !region->match(coords[m][0], coords[m][1], coords[m][2])) flag = 1;
+  }
+  MPI_Allreduce(&flag, &flagall, 1, MPI_INT, MPI_MAX, world);
+  if (comm->me == 0 && flagall == 1)
+    std::cout << "USHER has moved the particle/molecule too much" << std::endl;
+
+  return flagall;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixObmdMerged::center_of_mass(int natom, double **coords, double *xcom)
+{
+  int m;
+  MathExtra::zero3(xcom);
+
+  for (m = 0; m < natom; m++) {
+    xcom[0] += coords[m][0];
+    xcom[1] += coords[m][2];
+    xcom[2] += coords[m][1];
+  }
+
+  xcom[0] = xcom[0] / natom;
+  xcom[1] = xcom[1] / natom;
+  xcom[2] = xcom[2] / natom;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixObmdMerged::mol_center_of_mass(int natom, int imol, double **coords, double *xcom)
+{
+  double *mass = atom->mass;
+  int m;
+  double massmol = 0.0;
+  MathExtra::zero3(xcom);
+
+  for (m = 0; m < natom; m++) {
+    xcom[0] += mass[onemols[imol]->type[m]] * coords[m][0];
+    xcom[1] += mass[onemols[imol]->type[m]] * coords[m][1];
+    xcom[2] += mass[onemols[imol]->type[m]] * coords[m][2];
+
+    massmol += mass[onemols[imol]->type[m]];
+  }
+
+  xcom[0] = xcom[0] / massmol;
+  xcom[1] = xcom[1] / massmol;
+  xcom[2] = xcom[2] / massmol;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixObmdMerged::calc_torque(int natom, double **coords, double *xcom, double *force_tmp,
+                                double *torq)
+{
+  int m;
+  double xrel[3];
+
+  for (m = 0; m < natom; m++) {
+    xrel[0] = coords[m][0] - xcom[0];
+    xrel[1] = coords[m][1] - xcom[1];
+    xrel[2] = coords[m][2] - xcom[2];
+  }
+  dtheta0 = 0.1;
+  dtheta0 = 0.1;
+  MathExtra::cross3(xrel, force_tmp, torq);
+}
+
+/* ---------------------------------------------------------------------- */
+
+double FixObmdMerged::energy(int i, int itype, double *coord, double *fusher)
+{
+  double delx, dely, delz, rsq;
+  int jtype;
+  double **x = atom->x;
+  int *type = atom->type;
+  int nlocal = atom->nlocal;
+
+  pair = force->pair;
+  cutsq = force->pair->cutsq;
+
+  double fpair = 0.0;
+  double factor_coul = 1.0;
+  double factor_lj = 1.0;
+  double total_energy = 0.0;
+
+  for (int j = 0; j < nlocal; j++) {
+    delx = coord[0] - x[j][0];
+    dely = coord[1] - x[j][1];
+    delz = coord[2] - x[j][2];
+
+    domain->minimum_image(FLERR, delx, dely, delz);
+    rsq = delx * delx + dely * dely + delz * delz;
+
+    jtype = type[j];
+
+    if (rsq < cutsq[itype][jtype]) {
+      total_energy += pair->single(i, j, itype, jtype, rsq, factor_coul, factor_lj, fpair);
+
+      fusher[0] += fpair * delx;
+      fusher[1] += fpair * dely;
+      fusher[2] += fpair * delz;
+    }
+  }
+
+  return total_energy;
+}
+
+/* ---------------------------------------------------------------------- */
+
+double FixObmdMerged::energy_atomistic_obmd(Region *iregion_var, double qi, int itype,
+                                            double *coord, double *fusher)
+{
+  double delx, dely, delz, rsq;
+  int jtype;
+
+  double **x = atom->x;
+  int *type = atom->type;
+  int nall = atom->nlocal + atom->nghost;
+  cutsq = force->pair->cutsq;
+  tagint *tag = atom->tag;
+  int nlocal = atom->nlocal;
+
+  // potential acting between atomistic particles
+  auto pair = dynamic_cast<PairLJCutRF *>(force->pair_match("lj/cut/rf", 1));
+
+  double fpair = 0.0;
+  double factor_coul = 1.0;
+  double factor_lj = 1.0;
+  double total_energy = 0.0;
+
+  for (int j = 0; j < nlocal; j++) {
+    delx = coord[0] - x[j][0];
+    dely = coord[1] - x[j][1];
+    delz = coord[2] - x[j][2];
+
+    domain->minimum_image(FLERR, delx, dely, delz);
+    rsq = delx * delx + dely * dely + delz * delz;
+
+    jtype = type[j];
+
+    if (rsq < cutsq[itype][jtype]) {
+      total_energy +=
+          pair->single_atomistic_obmd(qi, j, itype, jtype, rsq, factor_coul, factor_lj, fpair);
+
+      fusher[0] += fpair * delx;
+      fusher[1] += fpair * dely;
+      fusher[2] += fpair * delz;
+    }
+  }
+
+  return total_energy;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixObmdMerged::find_maxid()
+{
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  int nlocal = atom->nlocal;
+
+  tagint max = 0;
+  for (int i = 0; i < nlocal; i++) max = MAX(max, tag[i]);
+  MPI_Allreduce(&max, &maxtag_all, 1, MPI_LMP_TAGINT, MPI_MAX, world);
+
+  if (mode == MOLECULE && molecule) {
+    max = 0;
+    for (int i = 0; i < nlocal; i++) max = MAX(max, molecule[i]);
+    MPI_Allreduce(&max, &maxmol_all, 1, MPI_LMP_TAGINT, MPI_MAX, world);
+  }
+}
+
+/* ----------------------------------------------------------------------
+   parse optional parameters at end of input line
+------------------------------------------------------------------------- */
+
+void FixObmdMerged::options(int narg, char **arg)
+{
+  // defaults
+  nearflag = 0;      // near
+  usherflag = 0;     // usher
+  chargeflag = 0;    // particle
+
+  iregion = nullptr;
+  idregion = nullptr;
+  iregion2 = nullptr;
+  idregion2 = nullptr;
+  iregion3 = nullptr;
+  idregion3 = nullptr;
+  iregion4 = nullptr;
+  idregion4 = nullptr;
+  iregion5 = nullptr;
+  idregion5 = nullptr;
+  iregion6 = nullptr;
+  idregion6 = nullptr;
+
+  mode = ATOM;
+  molfrac = nullptr;
+  rigidflag = 0;
+  idrigid = nullptr;
+  shakeflag = 0;
+  idshake = nullptr;
+  idnext = 0;
+
+  g_fac = 0.25;
+  g_fac_inv = 1.0 / g_fac;
+  mol_len = 1.0;    // particle
+  buffer_size = 0.30 * (domain->boxhi[0] - domain->boxlo[0]);
+
+  etarget = 3.6;
+  ds0 = 0.1;
+  dtheta0 = 0.35;
+  uovlp = 10000.0;
+  dsovlp = 3.0;
+  eps = 0.15;
+  nattempt = 40;
+  maxattempt = 1;
+
+  globalflag = localflag = 0;
+  lo = hi = deltasq = 0.0;
+  nearsq = 0.0;
+  rateflag = 0;
+  vxlo = vxhi = vylo = vyhi = vzlo = vzhi = 0.0;
+  distflag = DIST_UNIFORM;
+  sigma = 1.0;
+  xmid = ymid = zmid = 0.0;
+  scaleflag = 1;
+  targetflag = 0;
+  orientflag = 0;
+  rx = 0.0;
+  ry = 0.0;
+  rz = 0.0;
+
+  step_parallel = 0;    // normal > smooth distribution function
+  step_perp = 1;        // tangential > heaviside step distribution function
+
+  int imol = -1;
+  int iarg = 0;
+  while (iarg < narg) {
+    if (strcmp(arg[iarg], "region1") == 0) {
+      iregion = domain->get_region_by_id(arg[iarg + 1]);
+      if (!iregion) error->all(FLERR, "Region ID {} for fix obmd does not exist", arg[iarg + 1]);
+      int n = strlen(arg[iarg + 1]) + 1;
+      idregion = new char[n];
+      strcpy(idregion, arg[iarg + 1]);
+      iarg += 2;
+    } else if (strcmp(arg[iarg], "region2") == 0) {
+      iregion2 = domain->get_region_by_id(arg[iarg + 1]);
+      if (!iregion2) error->all(FLERR, "Region ID {} for fix obmd does not exist", arg[iarg + 1]);
+      int n = strlen(arg[iarg + 1]) + 1;
+      idregion2 = new char[n];
+      strcpy(idregion2, arg[iarg + 1]);
+      iarg += 2;
+    } else if (strcmp(arg[iarg], "region3") == 0) {
+      iregion3 = domain->get_region_by_id(arg[iarg + 1]);
+      if (!iregion3) error->all(FLERR, "Region ID {} for fix obmd does not exist", arg[iarg + 1]);
+      int n = strlen(arg[iarg + 1]) + 1;
+      idregion3 = new char[n];
+      strcpy(idregion3, arg[iarg + 1]);
+      iarg += 2;
+    } else if (strcmp(arg[iarg], "region4") == 0) {
+      iregion4 = domain->get_region_by_id(arg[iarg + 1]);
+      if (!iregion4) error->all(FLERR, "Region ID {} for fix obmd does not exist", arg[iarg + 1]);
+      int n = strlen(arg[iarg + 1]) + 1;
+      idregion4 = new char[n];
+      strcpy(idregion4, arg[iarg + 1]);
+      iarg += 2;
+    } else if (strcmp(arg[iarg], "region5") == 0) {
+      iregion5 = domain->get_region_by_id(arg[iarg + 1]);
+      if (!iregion5) error->all(FLERR, "Region ID {} for fix obmd does not exist", arg[iarg + 1]);
+      int n = strlen(arg[iarg + 1]) + 1;
+      idregion5 = new char[n];
+      strcpy(idregion5, arg[iarg + 1]);
+      iarg += 2;
+    } else if (strcmp(arg[iarg], "region6") == 0) {
+      iregion6 = domain->get_region_by_id(arg[iarg + 1]);
+      if (!iregion6) error->all(FLERR, "Region ID {} for fix obmd does not exist", arg[iarg + 1]);
+      int n = strlen(arg[iarg + 1]) + 1;
+      idregion6 = new char[n];
+      strcpy(idregion6, arg[iarg + 1]);
+      iarg += 2;
+    } else if (strcmp(arg[iarg], "buffersize") == 0) {
+      buffer_size = utils::numeric(FLERR, arg[iarg + 1], false, lmp);
+      if (buffer_size <= 0.0)
+        error->all(FLERR,
+                   "Illegal fix obmd command. Parameter buffersize should be larger than 0.0");
+      iarg += 2;
+    } else if (strcmp(arg[iarg], "gfac") == 0) {
+      g_fac = utils::numeric(FLERR, arg[iarg + 1], false, lmp);
+      g_fac_inv = 1.0 / g_fac;
+      if (g_fac < 0.0 || g_fac > 1.0)
+        error->all(FLERR, "Illegal fix obmd command. Parameter gfac should be between 0.0 and 1.0");
+      iarg += 2;
+    } /* else if (strcmp(arg[iarg],"alpha") == 0) {
+      alpha = utils::numeric(FLERR,arg[iarg+1],false,lmp);
+      if (alpha < 0.0) error->all(FLERR,"Parameter alpha should be bigger than 0.0");
+      iarg += 2;
+    }  else if (strcmp(arg[iarg],"tau") == 0) {
+      tau = utils::numeric(FLERR,arg[iarg+1],false,lmp);
+      if (tau < 0.0) error->all(FLERR,"Parameter tau should be bigger than 0.0");
+      iarg += 2;
+    } else if (strcmp(arg[iarg],"nbuf") == 0) {
+      nbuf = utils::numeric(FLERR,arg[iarg+1],false,lmp);
+      if (nbuf < 0.0) error->all(FLERR,"Parameter nbuf should be bigger than 0");
+      iarg += 2;
+    } */
+    else if (strcmp(arg[iarg], "stepparallel") == 0) {    // step function for parallel forces
+      step_parallel = utils::inumeric(FLERR, arg[iarg + 1], false, lmp);    // 1 / 0
+      if (step_parallel != 0)
+        error->all(FLERR,
+                   "For now, only the smooth transition distribution function is implemented.");
+      iarg += 2;
+    } else if (strcmp(arg[iarg], "stepperp") == 0) {    // step function for perpendicular forces
+      step_perp = utils::inumeric(FLERR, arg[iarg + 1], false, lmp);    // 1 / 0
+      if (step_perp != 1)
+        error->all(FLERR, "For now, only the heaviside step distribution function is implemented.");
+      iarg += 2;
+    } else if (strcmp(arg[iarg], "maxattempt") == 0) {    // not USHER attempts
+      maxattempt = utils::inumeric(FLERR, arg[iarg + 1], false, lmp);
+      iarg += 2;
+    } else if (strcmp(arg[iarg], "usher") == 0) {
+      if (iarg + 9 > narg) error->all(FLERR, "Illegal fix obmd command");
+      usherflag = utils::inumeric(FLERR, arg[iarg + 1], false, lmp);
+      if (usherflag == 1 && nearflag == 1)
+        error->all(FLERR, "You can not have both usher and near");
+      // options
+      etarget = utils::numeric(FLERR, arg[iarg + 2], false, lmp);
+      ds0 = utils::numeric(FLERR, arg[iarg + 3], false, lmp);
+      dtheta0 = utils::numeric(FLERR, arg[iarg + 4], false, lmp);
+      uovlp = utils::numeric(FLERR, arg[iarg + 5], false, lmp);
+      dsovlp = utils::numeric(FLERR, arg[iarg + 6], false, lmp);
+      eps = utils::numeric(FLERR, arg[iarg + 7], false, lmp);
+      nattempt = utils::inumeric(FLERR, arg[iarg + 8], false, lmp);
+      iarg += 9;
+    } else if (strcmp(arg[iarg], "mol") == 0) {
+      if (iarg + 3 > narg) error->all(FLERR, "Illegal fix obmd command");
+      imol = atom->find_molecule(arg[iarg + 1]);
+      if (imol == -1) error->all(FLERR, "Molecule template ID for fix obmd does not exist");
+      mol_len = utils::inumeric(FLERR, arg[iarg + 2], false, lmp);
+      mode = MOLECULE;
+      onemols = &atom->molecules[imol];
+      onemols[imol]->compute_mass();
+      mtot = onemols[imol]->masstotal;
+      nmol = onemols[0]->nset;
+      delete[] molfrac;
+      molfrac = new double[nmol];
+      molfrac[0] = 1.0 / nmol;
+      for (int i = 1; i < nmol - 1; i++) molfrac[i] = molfrac[i - 1] + 1.0 / nmol;
+      molfrac[nmol - 1] = 1.0;
+      iarg += 3;
+    } else if (strcmp(arg[iarg], "molfrac") == 0) {
+      if (mode != MOLECULE) error->all(FLERR, "You can not use molfrac without MOLECULE mode");
+      if (iarg + nmol + 1 > narg) error->all(FLERR, "Illegal fix obmd command");
+      molfrac[0] = utils::numeric(FLERR, arg[iarg + 1], false, lmp);
+      for (int i = 1; i < nmol; i++)
+        molfrac[i] = molfrac[i - 1] + utils::numeric(FLERR, arg[iarg + i + 1], false, lmp);
+      if (molfrac[nmol - 1] < 1.0 - EPSILON || molfrac[nmol - 1] > 1.0 + EPSILON)
+        error->all(FLERR, "Illegal fix obmd command");
+      molfrac[nmol - 1] = 1.0;
+      iarg += nmol + 1;
+    } else if (strcmp(arg[iarg], "rigid") == 0) {
+      int n = strlen(arg[iarg + 1]) + 1;
+      delete[] idrigid;
+      idrigid = new char[n];
+      strcpy(idrigid, arg[iarg + 1]);
+      rigidflag = 1;
+      iarg += 2;
+    } else if (strcmp(arg[iarg], "shake") == 0) {
+      int n = strlen(arg[iarg + 1]) + 1;
+      delete[] idshake;
+      idshake = new char[n];
+      strcpy(idshake, arg[iarg + 1]);
+      shakeflag = 1;
+      iarg += 2;
+    } else if (strcmp(arg[iarg], "id") == 0) {
+      if (strcmp(arg[iarg + 1], "max") == 0)
+        idnext = 0;
+      else if (strcmp(arg[iarg + 1], "next") == 0)
+        idnext = 1;
+      else
+        error->all(FLERR, "Illegal fix obmd command");
+      iarg += 2;
+    } else if (strcmp(arg[iarg], "global") == 0) {
+      globalflag = 1;
+      localflag = 0;
+      lo = utils::numeric(FLERR, arg[iarg + 1], false, lmp);
+      hi = utils::numeric(FLERR, arg[iarg + 2], false, lmp);
+      iarg += 3;
+    } else if (strcmp(arg[iarg], "local") == 0) {
+      localflag = 1;
+      globalflag = 0;
+      lo = utils::numeric(FLERR, arg[iarg + 1], false, lmp);
+      hi = utils::numeric(FLERR, arg[iarg + 2], false, lmp);
+      deltasq = utils::numeric(FLERR, arg[iarg + 3], false, lmp) *
+          utils::numeric(FLERR, arg[iarg + 3], false, lmp);
+      iarg += 4;
+    } else if (strcmp(arg[iarg], "near") == 0) {
+      nearflag = utils::inumeric(FLERR, arg[iarg + 1], false, lmp);
+      nearsq = utils::numeric(FLERR, arg[iarg + 2], false, lmp) *
+          utils::numeric(FLERR, arg[iarg + 2], false, lmp);
+      if (usherflag == 1 && nearflag == 1)
+        error->all(FLERR, "You can not have both usher and near");
+      iarg += 3;
+    } else if (strcmp(arg[iarg], "charged") == 0) {
+      chargeflag = utils::inumeric(FLERR, arg[iarg + 1], false, lmp);
+      if (chargeflag == 1 && mode != MOLECULE)
+        error->all(FLERR, "You can not use charged without MOLECULE mode");
+      iarg += 2;
+    } else if (strcmp(arg[iarg], "rate") == 0) {
+      rateflag = 1;
+      rate = utils::numeric(FLERR, arg[iarg + 1], false, lmp);
+      iarg += 2;
+    } else if (strcmp(arg[iarg], "vx") == 0) {
+      vxlo = utils::numeric(FLERR, arg[iarg + 1], false, lmp);
+      vxhi = utils::numeric(FLERR, arg[iarg + 2], false, lmp);
+      iarg += 3;
+    } else if (strcmp(arg[iarg], "vy") == 0) {
+      vylo = utils::numeric(FLERR, arg[iarg + 1], false, lmp);
+      vyhi = utils::numeric(FLERR, arg[iarg + 2], false, lmp);
+      iarg += 3;
+    } else if (strcmp(arg[iarg], "vz") == 0) {
+      vzlo = utils::numeric(FLERR, arg[iarg + 1], false, lmp);
+      vzhi = utils::numeric(FLERR, arg[iarg + 2], false, lmp);
+      iarg += 3;
+    } else if (strcmp(arg[iarg], "orient") == 0) {
+      orientflag = 1;
+      rx = utils::numeric(FLERR, arg[iarg + 1], false, lmp);
+      ry = utils::numeric(FLERR, arg[iarg + 2], false, lmp);
+      rz = utils::numeric(FLERR, arg[iarg + 3], false, lmp);
+      if (domain->dimension == 2 && (rx != 0.0 || ry != 0.0))
+        error->all(FLERR, "Illegal fix obmd orient settings");
+      if (rx == 0.0 && ry == 0.0 && rz == 0.0)
+        error->all(FLERR, "Illegal fix obmd orient settings");
+      iarg += 4;
+    } else if (strcmp(arg[iarg], "units") == 0) {
+      if (strcmp(arg[iarg + 1], "box") == 0)
+        scaleflag = 0;
+      else if (strcmp(arg[iarg + 1], "lattice") == 0)
+        scaleflag = 1;
+      else
+        error->all(FLERR, "Illegal fix obmd command");
+      iarg += 2;
+    } else if (strcmp(arg[iarg], "gaussian") == 0) {
+      xmid = utils::numeric(FLERR, arg[iarg + 1], false, lmp);
+      ymid = utils::numeric(FLERR, arg[iarg + 2], false, lmp);
+      zmid = utils::numeric(FLERR, arg[iarg + 3], false, lmp);
+      sigma = utils::numeric(FLERR, arg[iarg + 4], false, lmp);
+      distflag = DIST_GAUSSIAN;
+      iarg += 5;
+    } else if (strcmp(arg[iarg], "target") == 0) {
+      tx = utils::numeric(FLERR, arg[iarg + 1], false, lmp);
+      ty = utils::numeric(FLERR, arg[iarg + 2], false, lmp);
+      tz = utils::numeric(FLERR, arg[iarg + 3], false, lmp);
+      targetflag = 1;
+    } else
+      error->all(FLERR, "Illegal fix obmd command");
+  }
+
+  if (usherflag == 0 && nearflag == 0) error->all(FLERR, "You must pick either usher or near");
+}
+
+/* ----------------------------------------------------------------------
+   extract particle radius for atom type = itype
+------------------------------------------------------------------------- */
+
+void *FixObmdMerged::extract(const char *str, int &itype)
+{
+  if (strcmp(str, "radius") == 0) {
+    if (mode == ATOM) {
+      if (itype == ntype)
+        oneradius = 0.5;
+      else
+        oneradius = 0.0;
+
+    } else {
+
+      // loop over onemols molecules
+      // skip a molecule with no atoms as large as itype
+
+      oneradius = 0.0;
+      for (int i = 0; i < nmol; i++) {
+        if (itype > ntype + onemols[i]->ntypes) continue;
+        double *radius = onemols[i]->radius;
+        int *type = onemols[i]->type;
+        int natoms = onemols[i]->natoms;
+
+        // check radii of atoms in Molecule with matching types
+        // default to 0.5, if radii not defined in Molecule
+        //   same as atom->avec->create_atom(), invoked in pre_exchange()
+
+        for (int i = 0; i < natoms; i++)
+          if (type[i] + ntype == itype) {
+            if (radius)
+              oneradius = MAX(oneradius, radius[i]);
+            else
+              oneradius = MAX(oneradius, 0.5);
+          }
+      }
+    }
+    itype = 0;
+    return &oneradius;
+  }
+
+  return nullptr;
+}
diff -ruN a/src/OBMD/fix_obmd_merged.h b/src/OBMD/fix_obmd_merged.h
--- a/src/OBMD/fix_obmd_merged.h	1970-01-01 01:00:00.000000000 +0100
+++ b/src/OBMD/fix_obmd_merged.h	2025-11-05 16:03:26.316157000 +0100
@@ -0,0 +1,174 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://lammps.sandia.gov/, Sandia National Laboratories
+   Steve Plimpton, sjplimp@sandia.gov
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+
+   Attribution:
+   - Original code by Sandia Corporation.
+   - OBMD extension uses portions of code derived from evaporate and deposit fix style:
+   https://docs.lammps.org/fix_evaporate.html
+   https://docs.lammps.org/fix_deposit.html
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+
+FixStyle(obmd, FixObmdMerged)
+
+#else
+
+#ifndef LMP_FIX_OBMD_MERGED_H
+#define LMP_FIX_OBMD_MERGED_H
+
+#include "fix.h"
+#include <fstream>
+
+namespace LAMMPS_NS {
+
+class FixObmdMerged : public Fix {
+ public:
+  FixObmdMerged(class LAMMPS *, int, char **);
+  ~FixObmdMerged();
+
+  int setmask();
+  void init();
+  void pre_exchange();
+  void post_force(int);
+  void setup(int);
+  void *extract(const char *, int &);
+
+ private:
+  int ninsert, ntype, nfreq, seed;
+  class Region *iregion, *iregion2, *iregion3, *iregion4, *iregion5, *iregion6;
+  int globalflag, localflag, maxattempt, rateflag, scaleflag, targetflag;
+  int mode, rigidflag, shakeflag, idnext, distflag, orientflag, usherflag, nearflag, chargeflag;
+  double lo, hi, deltasq, nearsq, rate, sigma;
+  double vxlo, vxhi, vylo, vyhi, vzlo, vzhi;
+  double xlo, xhi, ylo, yhi, zlo, zhi, xmid, ymid, zmid;
+  double rx, ry, rz, tx, ty, tz;
+
+  int imol;
+  int iarg;    // args
+
+  char *idregion;
+  char *idregion2;
+  char *idregion3;
+  char *idregion4;
+  char *idregion5;
+  char *idregion6;
+  char *idrigid, *idshake;
+
+  int alphastyle, taustyle, nbufstyle;
+  int alphavar, tauvar, nbufvar;
+  char *alphastr, *taustr, *nbufstr;
+
+  int pxxstyle, pxystyle, pxzstyle, dpstyle, freqstyle;
+  int pxxvar, pxyvar, pxzvar, dpvar, freqvar;
+  char *pxxstr, *pxystr, *pxzstr, *dpstr, *freqstr;
+
+  double tau, alpha, buffer_size, shear_size, nbuf;
+  double pxx, pxy, pxz, dpxx, freq;
+  double mol_len;
+
+  void check_ghosts();
+  bigint lastcheck;
+
+  double vcml[3];
+  double vcmr[3];
+
+  // for inserting and deleting of particles/molecules
+  double vnewl[3];
+  double vnewr[3];
+  double vnewl_all[3];
+  double vnewr_all[3];
+
+  int me;
+  class Molecule **onemols;
+  int nmol, natom_max;
+  double *molfrac;
+  double **coords;
+  imageint *imageflags;
+  class Fix *fixrigid, *fixshake;
+  double oneradius;
+
+  int xstyle, xvar;
+  char *xstr;
+  int ystyle, yvar;
+  char *ystr;
+  int zstyle, zvar;
+  char *zstr;
+
+  int nfirst, ninserted;
+  tagint maxtag_all, maxmol_all;
+  class RanPark *random;
+
+  void find_maxid();
+  void options(int, char **);
+  double momentumForce_left[3];
+  double momentumForce_right[3];
+  int *list, *mark;
+  int ndeleted, ncount2, nmax, nmax2;
+
+  void try_inserting(Region *, int, double *vnewl, double *vnewr);
+  void try_deleting(Region *, double *vnewl, double *vnewr);
+  void reg_force(int, Region *, double *, int);
+  void reg_force_perp(int, Region *, double *, int);
+  double g_par_global(Region *, int);
+  double g_par_global_charged(Region *, int);
+  double g_perp_global(Region *, int);
+  double g_perp_global_charged(Region *, int);
+  double g_par_local(Region *, double, int);
+  double g_par_local_charged(double, Region *, double, int);
+  double energy(int, int, double *, double *);
+  double usher(Region *, double **, double, int, int, int &);
+  double energy_atomistic_obmd(Region *, double, int, double *,
+                               double *);    // charge qi, type, coords, fusher
+  double near_energy(Region *, double **, int, int);
+  void center_of_mass(int, double **, double *);
+  void mol_center_of_mass(int, int, double **, double *);
+  void calc_torque(int, double **, double *, double *, double *);
+  int check_proc(double **, double *, double *, double *, int);
+  int check_mol_proc(double **, double *, double *, double *, double *, int, int, int &);
+  int check_mol_region(Region *, double **, int);
+  void vcm_internal_sq(int, double, double *, double *, double *, Region *);
+  double xvalue, yvalue, zvalue;
+  int varflag;
+
+  double foriginal[4], foriginal_all[4];
+  int force_flag;
+  int print_delete_flag;
+  int print_insert_flag;
+  int stepflag;
+  int step_parallel, step_perp;
+  double g_fac, g_fac_inv;
+  int maxatom;
+  double **sforce;
+
+  class Compute *pressure_tensor;
+
+  double mtot;
+
+  double fusher[3];
+  double shearForce_left[3];
+  double shearForce_right[3];
+  double simulation_time;
+  double pressure_wave;
+
+  double **cutsq;
+  class Pair *pair;
+  double masstotal;
+  int nattempt;    // usher
+  double uovlp, dsovlp, eps, ds0, dtheta0, etarget;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN a/src/pair_lj_cut_rf.cpp b/src/pair_lj_cut_rf.cpp
--- a/src/pair_lj_cut_rf.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/src/pair_lj_cut_rf.cpp	2025-11-05 16:03:09.119880000 +0100
@@ -0,0 +1,612 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+
+   Attribution:
+   - Original code by Sandia Corporation.
+   - lj/cut/rf uses portions of code derived from lj/cut/coul/cut pair style:
+   https://docs.lammps.org/pair_lj_cut_coul.html
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "pair_lj_cut_rf.h"
+
+#include "atom.h"
+#include "comm.h"
+#include "error.h"
+#include "force.h"
+#include "math_const.h"
+#include "memory.h"
+#include "neigh_list.h"
+#include "neighbor.h"
+#include <cmath>
+#include <cstring>
+
+#include <iostream>
+
+using namespace LAMMPS_NS;
+using namespace MathConst;
+
+/* ---------------------------------------------------------------------- */
+
+PairLJCutRF::PairLJCutRF(LAMMPS *lmp) : Pair(lmp)
+{
+  born_matrix_enable = 1;
+  writedata = 1;
+}
+
+/* ---------------------------------------------------------------------- */
+
+PairLJCutRF::~PairLJCutRF()
+{
+  if (copymode) return;
+
+  if (allocated) {
+    memory->destroy(setflag);
+    memory->destroy(cutsq);
+
+    memory->destroy(cut_lj);
+    memory->destroy(cut_ljsq);
+    memory->destroy(cut_coul);
+    memory->destroy(cut_coulsq);
+    memory->destroy(epsilon);
+    memory->destroy(sigma);
+    memory->destroy(lj1);
+    memory->destroy(lj2);
+    memory->destroy(lj3);
+    memory->destroy(lj4);
+    memory->destroy(offset);
+
+    memory->destroy(epsilon_rf);
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void PairLJCutRF::compute(int eflag, int vflag)
+{
+  int i, j, ii, jj, inum, jnum, itype, jtype;
+  double qtmp, xtmp, ytmp, ztmp, delx, dely, delz, evdwl, ecoul, fpair;
+  double rsq, r2inv, r6inv, forcecoul, forcelj, factor_coul, factor_lj;
+  int *ilist, *jlist, *numneigh, **firstneigh;
+
+  double fpairlj, fpaircoul;
+  evdwl = ecoul = 0.0;
+  ev_init(eflag, vflag);
+
+  double **x = atom->x;
+  double **f = atom->f;
+  double *q = atom->q;
+  int *type = atom->type;
+  int nlocal = atom->nlocal;
+  double *special_coul = force->special_coul;
+  double *special_lj = force->special_lj;
+  int newton_pair = force->newton_pair;
+  double qqrd2e = force->qqrd2e;
+
+  inum = list->inum;
+  ilist = list->ilist;
+  numneigh = list->numneigh;
+  firstneigh = list->firstneigh;
+
+  // loop over neighbors of my atoms
+
+  for (ii = 0; ii < inum; ii++) {
+    i = ilist[ii];
+    qtmp = q[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    itype = type[i];
+    jlist = firstneigh[i];
+    jnum = numneigh[i];
+
+
+    for (jj = 0; jj < jnum; jj++) {
+      j = jlist[jj];
+      factor_lj = special_lj[sbmask(j)];
+      factor_coul = special_coul[sbmask(j)];
+      j &= NEIGHMASK;
+
+      delx = xtmp - x[j][0];
+      dely = ytmp - x[j][1];
+      delz = ztmp - x[j][2];
+      rsq = delx * delx + dely * dely + delz * delz;
+      jtype = type[j];
+
+      if (rsq < cutsq[itype][jtype]) {
+        r2inv = 1.0 / rsq;
+
+        // terms for reaction field 
+        double rf_fctr_0 = 1.0 / pow(sqrt(rsq),3.0);
+        double rf_fctr_1 = (epsilon_rf[itype][jtype] - 1.0);
+        double rf_fctr_2 = 1.0 + 2.0 * epsilon_rf[itype][jtype];
+
+        if (rsq < cut_coulsq[itype][jtype]) {
+          forcecoul = (qqrd2e * qtmp * q[j]) * ((r2inv*sqrt(r2inv)) - (1.0 / pow(cut_coul[itype][jtype],3.0) * (2.0 * rf_fctr_1 / rf_fctr_2)));
+        }
+        else {
+          forcecoul = 0.0;
+        }
+
+        if (rsq < cut_ljsq[itype][jtype]) {
+          r6inv = r2inv * r2inv * r2inv;
+          forcelj = r6inv * (lj1[itype][jtype] * r6inv - lj2[itype][jtype]);
+        } else
+          forcelj = 0.0;
+
+        fpairlj = factor_lj * forcelj * r2inv;
+        fpaircoul = factor_coul * forcecoul; 
+        fpair = fpairlj + fpaircoul;
+
+        f[i][0] += delx * fpair;
+        f[i][1] += dely * fpair;
+        f[i][2] += delz * fpair;
+        if (newton_pair || j < nlocal) {
+          f[j][0] -= delx * fpair;
+          f[j][1] -= dely * fpair;
+          f[j][2] -= delz * fpair;
+        }
+
+        if (f[i][0] > 10000 || f[i][1] > 10000 || f[i][2] > 10000) {
+          std::cout<<"PairLJCutRF::compute"<<"\n";
+          std::cout<<"f[i][0]: "<<f[i][0]<<"\n";
+          std::cout<<"f[i][1]: "<<f[i][1]<<"\n";
+          std::cout<<"f[i][2]: "<<f[i][2]<<"\n";
+        }
+
+        if (eflag) {
+          if (rsq < cut_coulsq[itype][jtype]) {
+            ecoul = (qqrd2e * qtmp * q[j]) * sqrt(r2inv) * (1.0 + (rf_fctr_1 / rf_fctr_2) * (pow(sqrt(rsq)/cut_coul[itype][jtype],3.0)))
+            - (qqrd2e * qtmp * q[j]) * (1.0 / cut_coul[itype][jtype]) * (3.0 * epsilon_rf[itype][jtype] / rf_fctr_2); 
+            ecoul *= factor_coul;
+          }
+          else {
+            ecoul = 0.0;
+          }
+          if (rsq < cut_ljsq[itype][jtype]) {
+            evdwl = r6inv * (lj3[itype][jtype] * r6inv - lj4[itype][jtype]) - offset[itype][jtype];
+            evdwl *= factor_lj;
+          } else
+            evdwl = 0.0;
+        }
+
+        if (evflag) ev_tally(i, j, nlocal, newton_pair, evdwl, ecoul, fpair, delx, dely, delz);
+      }
+    }
+  }
+
+  if (vflag_fdotr) virial_fdotr_compute();
+}
+
+/* ----------------------------------------------------------------------
+   allocate all arrays
+------------------------------------------------------------------------- */
+
+void PairLJCutRF::allocate()
+{
+  allocated = 1;
+  int np1 = atom->ntypes + 1;
+
+  memory->create(setflag, np1, np1, "pair:setflag");
+  for (int i = 1; i < np1; i++)
+    for (int j = i; j < np1; j++) setflag[i][j] = 0;
+
+  memory->create(cutsq, np1, np1, "pair:cutsq");
+  memory->create(cut_lj, np1, np1, "pair:cut_lj");
+  memory->create(cut_ljsq, np1, np1, "pair:cut_ljsq");
+  memory->create(cut_coul, np1, np1, "pair:cut_coul");
+  memory->create(cut_coulsq, np1, np1, "pair:cut_coulsq");
+  memory->create(epsilon, np1, np1, "pair:epsilon");
+  memory->create(sigma, np1, np1, "pair:sigma");
+  memory->create(lj1, np1, np1, "pair:lj1");
+  memory->create(lj2, np1, np1, "pair:lj2");
+  memory->create(lj3, np1, np1, "pair:lj3");
+  memory->create(lj4, np1, np1, "pair:lj4");
+  memory->create(offset, np1, np1, "pair:offset");
+  memory->create(epsilon_rf, np1, np1, "pair:epsilon_rf");
+
+}
+
+/* ----------------------------------------------------------------------
+   global settings
+------------------------------------------------------------------------- */
+
+void PairLJCutRF::settings(int narg, char **arg)
+{
+  if (narg < 1 || narg > 2) error->all(FLERR, "Illegal pair_style command");
+
+  cut_lj_global = utils::numeric(FLERR, arg[0], false, lmp);
+  if (narg == 1)
+    cut_coul_global = cut_lj_global;
+  else
+    cut_coul_global = utils::numeric(FLERR, arg[1], false, lmp);
+
+  // reset cutoffs that have been explicitly set
+
+  if (allocated) {
+    int i, j;
+    for (i = 1; i <= atom->ntypes; i++)
+      for (j = i; j <= atom->ntypes; j++)
+        if (setflag[i][j]) {
+          cut_lj[i][j] = cut_lj_global;
+          cut_coul[i][j] = cut_coul_global;
+        }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   set coeffs for one or more type pairs
+------------------------------------------------------------------------- */
+
+void PairLJCutRF::coeff(int narg, char **arg)
+{
+  
+  if (narg < 5 || narg > 7) error->all(FLERR, "Incorrect args for pair coefficients");
+  if (!allocated) allocate();
+
+  int ilo, ihi, jlo, jhi;
+  utils::bounds(FLERR, arg[0], 1, atom->ntypes, ilo, ihi, error);
+  utils::bounds(FLERR, arg[1], 1, atom->ntypes, jlo, jhi, error);
+
+  double epsilon_one = utils::numeric(FLERR, arg[2], false, lmp);
+  double sigma_one = utils::numeric(FLERR, arg[3], false, lmp);
+
+  double cut_lj_one = cut_lj_global;
+  double cut_coul_one = cut_coul_global;
+  epsilon_rf_one = utils::numeric(FLERR, arg[4], false, lmp);
+
+  if (narg >= 6) {
+    cut_coul_one = cut_lj_one = utils::numeric(FLERR, arg[4], false, lmp);
+    epsilon_rf_one = utils::numeric(FLERR, arg[5], false, lmp);
+  }
+  if (narg == 7) {
+    cut_lj_one = utils::numeric(FLERR, arg[4], false, lmp);
+    cut_coul_one = utils::numeric(FLERR, arg[5], false, lmp);
+    epsilon_rf_one = utils::numeric(FLERR, arg[6], false, lmp);
+  }
+
+  int count = 0;
+  for (int i = ilo; i <= ihi; i++) {
+    for (int j = MAX(jlo, i); j <= jhi; j++) {
+      epsilon[i][j] = epsilon_one;
+      sigma[i][j] = sigma_one;
+      cut_lj[i][j] = cut_lj_one;
+      cut_coul[i][j] = cut_coul_one;
+
+      // reaction field param
+      epsilon_rf[i][j] = epsilon_rf_one; 
+
+      setflag[i][j] = 1;
+      count++;
+    }
+  }
+
+  if (count == 0) error->all(FLERR, "Incorrect args for pair coefficients");
+}
+
+/* ----------------------------------------------------------------------
+   init specific to this pair style
+------------------------------------------------------------------------- */
+
+void PairLJCutRF::init_style()
+{
+  if (!atom->q_flag) error->all(FLERR, "Pair style lj/cut/rf requires atom attribute q");
+
+  neighbor->add_request(this);
+}
+
+/* ----------------------------------------------------------------------
+   init for one type pair i,j and corresponding j,i
+------------------------------------------------------------------------- */
+
+double PairLJCutRF::init_one(int i, int j)
+{
+  if (setflag[i][j] == 0) {
+    epsilon[i][j] = mix_energy(epsilon[i][i], epsilon[j][j], sigma[i][i], sigma[j][j]);
+    sigma[i][j] = mix_distance(sigma[i][i], sigma[j][j]);
+    cut_lj[i][j] = mix_distance(cut_lj[i][i], cut_lj[j][j]);
+    cut_coul[i][j] = mix_distance(cut_coul[i][i], cut_coul[j][j]);
+  }
+
+  double cut = MAX(cut_lj[i][j], cut_coul[i][j]);
+  cut_ljsq[i][j] = cut_lj[i][j] * cut_lj[i][j];
+  cut_coulsq[i][j] = cut_coul[i][j] * cut_coul[i][j];
+
+  lj1[i][j] = 48.0 * epsilon[i][j] * pow(sigma[i][j], 12.0);
+  lj2[i][j] = 24.0 * epsilon[i][j] * pow(sigma[i][j], 6.0);
+  lj3[i][j] = 4.0 * epsilon[i][j] * pow(sigma[i][j], 12.0);
+  lj4[i][j] = 4.0 * epsilon[i][j] * pow(sigma[i][j], 6.0);
+
+  if (offset_flag && (cut_lj[i][j] > 0.0)) {
+    double ratio = sigma[i][j] / cut_lj[i][j];
+    offset[i][j] = 4.0 * epsilon[i][j] * (pow(ratio, 12.0) - pow(ratio, 6.0));
+  } else
+    offset[i][j] = 0.0;
+
+  cut_ljsq[j][i] = cut_ljsq[i][j];
+  cut_coul[j][i] = cut_coul[i][j]; 
+  cut_coulsq[j][i] = cut_coulsq[i][j];
+  lj1[j][i] = lj1[i][j];
+  lj2[j][i] = lj2[i][j];
+  lj3[j][i] = lj3[i][j];
+  lj4[j][i] = lj4[i][j];
+
+  epsilon_rf[j][i] = epsilon_rf[i][j];
+
+  offset[j][i] = offset[i][j];
+
+  // compute I,J contribution to long-range tail correction
+  // count total # of atoms of type I and J via Allreduce
+
+  if (tail_flag) {
+    int *type = atom->type;
+    int nlocal = atom->nlocal;
+
+    double count[2], all[2];
+    count[0] = count[1] = 0.0;
+    for (int k = 0; k < nlocal; k++) {
+      if (type[k] == i) count[0] += 1.0;
+      if (type[k] == j) count[1] += 1.0;
+    }
+    MPI_Allreduce(count, all, 2, MPI_DOUBLE, MPI_SUM, world);
+
+    double sig2 = sigma[i][j] * sigma[i][j];
+    double sig6 = sig2 * sig2 * sig2;
+    double rc3 = cut_lj[i][j] * cut_lj[i][j] * cut_lj[i][j];
+    double rc6 = rc3 * rc3;
+    double rc9 = rc3 * rc6;
+    etail_ij =
+        8.0 * MY_PI * all[0] * all[1] * epsilon[i][j] * sig6 * (sig6 - 3.0 * rc6) / (9.0 * rc9);
+    ptail_ij = 16.0 * MY_PI * all[0] * all[1] * epsilon[i][j] * sig6 * (2.0 * sig6 - 3.0 * rc6) /
+        (9.0 * rc9);
+  }
+
+  return cut;
+}
+
+/* ----------------------------------------------------------------------
+  proc 0 writes to restart file
+------------------------------------------------------------------------- */
+
+void PairLJCutRF::write_restart(FILE *fp)
+{
+  /* write_restart_settings(fp);
+
+  int i, j;
+  for (i = 1; i <= atom->ntypes; i++)
+    for (j = i; j <= atom->ntypes; j++) {
+      fwrite(&setflag[i][j], sizeof(int), 1, fp);
+      if (setflag[i][j]) {
+        fwrite(&epsilon[i][j], sizeof(double), 1, fp);
+        fwrite(&sigma[i][j], sizeof(double), 1, fp);
+        fwrite(&cut_lj[i][j], sizeof(double), 1, fp);
+        fwrite(&cut_coul[i][j], sizeof(double), 1, fp);
+      }
+    } */
+  ;
+}
+
+/* ----------------------------------------------------------------------
+  proc 0 reads from restart file, bcasts
+------------------------------------------------------------------------- */
+
+void PairLJCutRF::read_restart(FILE *fp)
+{
+  /* read_restart_settings(fp);
+  allocate();
+
+  int i, j;
+  int me = comm->me;
+  for (i = 1; i <= atom->ntypes; i++)
+    for (j = i; j <= atom->ntypes; j++) {
+      if (me == 0) utils::sfread(FLERR, &setflag[i][j], sizeof(int), 1, fp, nullptr, error);
+      MPI_Bcast(&setflag[i][j], 1, MPI_INT, 0, world);
+      if (setflag[i][j]) {
+        if (me == 0) {
+          utils::sfread(FLERR, &epsilon[i][j], sizeof(double), 1, fp, nullptr, error);
+          utils::sfread(FLERR, &sigma[i][j], sizeof(double), 1, fp, nullptr, error);
+          utils::sfread(FLERR, &cut_lj[i][j], sizeof(double), 1, fp, nullptr, error);
+          utils::sfread(FLERR, &cut_coul[i][j], sizeof(double), 1, fp, nullptr, error);
+        }
+        MPI_Bcast(&epsilon[i][j], 1, MPI_DOUBLE, 0, world);
+        MPI_Bcast(&sigma[i][j], 1, MPI_DOUBLE, 0, world);
+        MPI_Bcast(&cut_lj[i][j], 1, MPI_DOUBLE, 0, world);
+        MPI_Bcast(&cut_coul[i][j], 1, MPI_DOUBLE, 0, world);
+      }
+    } */
+  ;
+}
+
+/* ----------------------------------------------------------------------
+  proc 0 writes to restart file
+------------------------------------------------------------------------- */
+
+void PairLJCutRF::write_restart_settings(FILE *fp)
+{
+  /* fwrite(&cut_lj_global, sizeof(double), 1, fp);
+  fwrite(&cut_coul_global, sizeof(double), 1, fp);
+  fwrite(&offset_flag, sizeof(int), 1, fp);
+  fwrite(&mix_flag, sizeof(int), 1, fp);
+  fwrite(&tail_flag, sizeof(int), 1, fp); */
+  ;
+}
+
+/* ----------------------------------------------------------------------
+  proc 0 reads from restart file, bcasts
+------------------------------------------------------------------------- */
+
+void PairLJCutRF::read_restart_settings(FILE *fp)
+{
+  /* if (comm->me == 0) {
+    utils::sfread(FLERR, &cut_lj_global, sizeof(double), 1, fp, nullptr, error);
+    utils::sfread(FLERR, &cut_coul_global, sizeof(double), 1, fp, nullptr, error);
+    utils::sfread(FLERR, &offset_flag, sizeof(int), 1, fp, nullptr, error);
+    utils::sfread(FLERR, &mix_flag, sizeof(int), 1, fp, nullptr, error);
+    utils::sfread(FLERR, &tail_flag, sizeof(int), 1, fp, nullptr, error);
+  }
+  MPI_Bcast(&cut_lj_global, 1, MPI_DOUBLE, 0, world);
+  MPI_Bcast(&cut_coul_global, 1, MPI_DOUBLE, 0, world);
+  MPI_Bcast(&offset_flag, 1, MPI_INT, 0, world);
+  MPI_Bcast(&mix_flag, 1, MPI_INT, 0, world);
+  MPI_Bcast(&tail_flag, 1, MPI_INT, 0, world); */
+  ;
+}
+
+/* ----------------------------------------------------------------------
+   proc 0 writes to data file
+------------------------------------------------------------------------- */
+
+void PairLJCutRF::write_data(FILE *fp)
+{
+  // for (int i = 1; i <= atom->ntypes; i++) fprintf(fp, "%d %g %g\n", i, epsilon[i][i], sigma[i][i]);
+  ;
+}
+
+/* ----------------------------------------------------------------------
+   proc 0 writes all pairs to data file
+------------------------------------------------------------------------- */
+
+void PairLJCutRF::write_data_all(FILE *fp)
+{
+  /* for (int i = 1; i <= atom->ntypes; i++)
+    for (int j = i; j <= atom->ntypes; j++)
+      fprintf(fp, "%d %d %g %g %g\n", i, j, epsilon[i][j], sigma[i][j], cut_lj[i][j]); */
+  ;
+}
+
+/* ---------------------------------------------------------------------- */
+
+double PairLJCutRF::single(int i, int j, int itype, int jtype, double rsq, double factor_coul,
+                                double factor_lj, double &fforce)
+{
+  double r2inv, r6inv, forcecoul, forcelj, phicoul, philj;
+
+  double rf_fctr_1 = (epsilon_rf[itype][jtype] - 1.0);
+  double rf_fctr_2 = 1.0 + 2.0 * epsilon_rf[itype][jtype];
+  r2inv = 1.0 / rsq;
+
+  if (rsq < cut_coulsq[itype][jtype]) {
+    forcecoul = (force->qqrd2e * atom->q[i] * atom->q[j]) 
+    * (r2inv*sqrt(r2inv) 
+    - (1.0 / pow(cut_coul[itype][jtype],3.0) * (2.0 * rf_fctr_1 / rf_fctr_2))); 
+  }
+  else {
+    forcecoul = 0.0;
+  }
+  if (rsq < cut_ljsq[itype][jtype]) {
+    r6inv = r2inv * r2inv * r2inv;
+    forcelj = r6inv * (lj1[itype][jtype] * r6inv - lj2[itype][jtype]);
+  } else
+    forcelj = 0.0;
+
+  fforce = factor_coul * forcecoul + factor_lj * forcelj * r2inv;
+
+  double eng = 0.0;
+  if (rsq < cut_coulsq[itype][jtype]) {
+    phicoul = force->qqrd2e * atom->q[i] * atom->q[j] * sqrt(r2inv) * (1.0 + (rf_fctr_1 / rf_fctr_2) * (pow(sqrt(rsq)/cut_coul[itype][jtype],3.0))) 
+    - force->qqrd2e * atom->q[i] * atom->q[j] * (1.0 / cut_coul[itype][jtype]) * (3.0 * epsilon_rf[itype][jtype] / rf_fctr_2); 
+    eng += factor_coul * phicoul;
+  }
+  if (rsq < cut_ljsq[itype][jtype]) {
+    philj = r6inv * (lj3[itype][jtype] * r6inv - lj4[itype][jtype]) - offset[itype][jtype];
+    eng += factor_lj * philj;
+  }
+
+  return eng;
+}
+
+/* ---------------------------------------------------------------------- */
+
+double PairLJCutRF::single_atomistic_obmd(double qi, int j, int itype, int jtype, double rsq, double factor_coul,
+                                double factor_lj, double &fforce)
+{
+
+  double r2inv, r6inv, forcecoul, forcelj, phicoul, philj;
+
+  double rf_fctr_1 = (epsilon_rf[itype][jtype] - 1.0);
+  double rf_fctr_2 = 1.0 + 2.0 * epsilon_rf[itype][jtype];
+
+  r2inv = 1.0 / rsq;
+  if (rsq < cut_coulsq[itype][jtype]) {
+    forcecoul = (force->qqrd2e * qi * atom->q[j]) 
+    * (r2inv*sqrt(r2inv) 
+    - (1.0 / pow(cut_coul[itype][jtype],3.0) * (2.0 * rf_fctr_1 / rf_fctr_2))); 
+  }
+  else {
+    forcecoul = 0.0;
+  }
+  if (rsq < cut_ljsq[itype][jtype]) {
+    r6inv = r2inv * r2inv * r2inv;
+    forcelj = r6inv * (lj1[itype][jtype] * r6inv - lj2[itype][jtype]);
+  } else
+    forcelj = 0.0;
+
+  fforce = factor_coul * forcecoul + factor_lj * forcelj * r2inv;
+
+  double eng = 0.0;
+  if (rsq < cut_coulsq[itype][jtype]) {
+    phicoul = force->qqrd2e * qi * atom->q[j] * sqrt(r2inv) * (1.0 + (rf_fctr_1 / rf_fctr_2) * (pow(sqrt(rsq)/cut_coul[itype][jtype],3.0))) 
+    - force->qqrd2e * qi * atom->q[j] * (1.0 / cut_coul[itype][jtype]) * (3.0 * epsilon_rf[itype][jtype] / rf_fctr_2); 
+    eng += factor_coul * phicoul;
+  }
+  if (rsq < cut_ljsq[itype][jtype]) {
+    philj = r6inv * (lj3[itype][jtype] * r6inv - lj4[itype][jtype]) - offset[itype][jtype];
+    eng += factor_lj * philj;
+  }
+
+  return eng;
+
+}
+
+/* ---------------------------------------------------------------------- */
+
+void PairLJCutRF::born_matrix(int i, int j, int itype, int jtype, double rsq,
+                                   double factor_coul, double factor_lj, double &dupair,
+                                   double &du2pair)
+{
+  
+  /* double rinv, r2inv, r3inv, r6inv;
+  double du_lj, du2_lj, du_coul, du2_coul;
+
+  double *q = atom->q;
+  double qqrd2e = force->qqrd2e;
+
+  r2inv = 1.0 / rsq;
+  rinv = sqrt(r2inv);
+  r3inv = r2inv * rinv;
+  r6inv = r2inv * r2inv * r2inv;
+
+  // Reminder: lj1 = 48*e*s^12, lj2 = 24*e*s^6
+
+  du_lj = r6inv * rinv * (lj2[itype][jtype] - lj1[itype][jtype] * r6inv);
+  du2_lj = r6inv * r2inv * (13 * lj1[itype][jtype] * r6inv - 7 * lj2[itype][jtype]);
+
+  du_coul = -qqrd2e * q[i] * q[j] * r2inv;
+  du2_coul = 2.0 * qqrd2e * q[i] * q[j] * r3inv;
+
+  dupair = factor_lj * du_lj + factor_coul * du_coul;
+  du2pair = factor_lj * du2_lj + factor_coul * du2_coul; */
+  ;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void *PairLJCutRF::extract(const char *str, int &dim)
+{
+  dim = 2;
+  if (strcmp(str, "cut_coul") == 0) return (void *) cut_coul;
+  if (strcmp(str, "epsilon") == 0) return (void *) epsilon;
+  if (strcmp(str, "sigma") == 0) return (void *) sigma;
+  if (strcmp(str, "epsilon_rf") == 0) return (void *) epsilon_rf;
+  
+  return nullptr;
+}
diff -ruN a/src/pair_lj_cut_rf.h b/src/pair_lj_cut_rf.h
--- a/src/pair_lj_cut_rf.h	1970-01-01 01:00:00.000000000 +0100
+++ b/src/pair_lj_cut_rf.h	2025-11-05 16:03:13.513165231 +0100
@@ -0,0 +1,70 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+
+    Attribution:
+   - Original code by Sandia Corporation.
+   - lj/cut/rf uses portions of code derived from lj/cut/coul/cut pair style:
+   https://docs.lammps.org/pair_lj_cut_coul.html
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef PAIR_CLASS
+// clang-format off
+PairStyle(lj/cut/rf,PairLJCutRF);
+// clang-format on
+#else
+
+#ifndef LMP_PAIR_LJ_CUT_RF_H
+#define LMP_PAIR_LJ_CUT_RF_H
+
+#include "pair.h"
+
+namespace LAMMPS_NS {
+
+class PairLJCutRF : public Pair {
+ public:
+  PairLJCutRF(class LAMMPS *);
+  ~PairLJCutRF() override;
+  void compute(int, int) override;
+  void settings(int, char **) override;
+  void coeff(int, char **) override;
+  void init_style() override;
+  double init_one(int, int) override;
+  void write_restart(FILE *) override;
+  void read_restart(FILE *) override;
+  void write_restart_settings(FILE *) override;
+  void read_restart_settings(FILE *) override;
+  void write_data(FILE *) override;
+  void write_data_all(FILE *) override;
+  double single(int, int, int, int, double, double, double, double &) override;
+  double single_atomistic_obmd(double, int, int, int, double, double, double, double &); // PP
+  void born_matrix(int, int, int, int, double, double, double, double &, double &) override;
+  void *extract(const char *, int &) override;
+
+ protected:
+  double cut_lj_global, cut_coul_global;
+  double **cut_lj, **cut_ljsq;
+  double **cut_coul, **cut_coulsq;
+  double **epsilon, **sigma;
+  double **lj1, **lj2, **lj3, **lj4, **offset;
+
+  // for reaction field
+  double epsilon_rf_one;
+  double **epsilon_rf;
+
+  virtual void allocate();
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN a/cmake/Modules/Packages/ALLPKG.cmake b/cmake/Modules/Packages/ALLPKG.cmake
--- a/cmake/Modules/Packages/ALLPKG.cmake	1970-01-01 01:00:00.000000000 +0100
+++ b/cmake/Modules/Packages/ALLPKG.cmake	2025-11-05 16:34:13.457313385 +0100
@@ -0,0 +1,40 @@
+# find required packages
+find_package(MPI REQUIRED)
+
+# try to find ALL
+set(DOWNLOAD_ALLPKG_DEFAULT ON)
+find_package(ALL QUIET)
+if(ALL_FOUND)
+  set(DOWNLOAD_ALLPKG_DEFAULT OFF)
+endif()
+
+option(DOWNLOAD_ALLPKG "Download ALL library instead of using an already installed one" ${DOWNLOAD_ALLPKG_DEFAULT})
+if(DOWNLOAD_ALLPKG)
+  # Download ALL and integrate it into the build process
+  message(STATUS "ALL download requested - we will build our own")
+  set(ALL_URL "https://gitlab.jsc.fz-juelich.de/SLMS/loadbalancing/-/archive/v0.9.3/loadbalancing-v0.9.3.tar.gz" CACHE STRING "URL for ALL tarball")
+  set(ALL_MD5 "9fc008711a7dfaf35e957411f8ed1504" CACHE STRING "MD5 checksum of ALL tarball")
+  mark_as_advanced(ALL_URL)
+  mark_as_advanced(ALL_MD5)
+  GetFallbackURL(ALL_URL ALL_FALLBACK)
+
+  include(ExternalProject)
+  ExternalProject_Add(ALL_build
+    URL     ${ALL_URL} ${ALL_FALLBACK}
+    URL_MD5 ${ALL_MD5}
+    CMAKE_ARGS
+      -DCMAKE_INSTALL_PREFIX=<INSTALL_DIR>
+      -DCMAKE_INSTALL_LIBDIR=lib
+  )
+
+  ExternalProject_get_property(ALL_build INSTALL_DIR)
+  file(MAKE_DIRECTORY ${INSTALL_DIR}/include)
+  add_library(LAMMPS::ALL INTERFACE IMPORTED)
+  add_dependencies(LAMMPS::ALL ALL_build)
+  set_target_properties(LAMMPS::ALL PROPERTIES INTERFACE_INCLUDE_DIRECTORIES "${INSTALL_DIR}/include")
+  target_link_libraries(lammps PRIVATE LAMMPS::ALL)
+else()
+  # link found ALL library
+  find_package(ALL REQUIRED)
+  target_link_libraries(lammps PRIVATE ALL::ALL)
+endif()
diff -ruN a/cmake/presets/all_off.cmake b/cmake/presets/all_off.cmake
--- a/cmake/presets/all_off.cmake	2025-11-05 15:55:49.629293881 +0100
+++ b/cmake/presets/all_off.cmake	2025-11-05 16:34:13.457644709 +0100
@@ -3,6 +3,7 @@
 
 set(ALL_PACKAGES
   ADIOS
+  ALLPKG
   AMOEBA
   APIP
   ASPHERE
diff -ruN a/cmake/presets/all_on.cmake b/cmake/presets/all_on.cmake
--- a/cmake/presets/all_on.cmake	2025-11-05 15:55:49.629841878 +0100
+++ b/cmake/presets/all_on.cmake	2025-11-05 16:34:13.457922412 +0100
@@ -5,6 +5,7 @@
 
 set(ALL_PACKAGES
   ADIOS
+  ALLPKG
   AMOEBA
   APIP
   ASPHERE
diff -ruN a/cmake/presets/download.cmake b/cmake/presets/download.cmake
--- a/cmake/presets/download.cmake	2025-11-05 15:55:49.628236629 +0100
+++ b/cmake/presets/download.cmake	2025-11-05 16:34:13.458174495 +0100
@@ -1,7 +1,7 @@
 # Preset that turns on packages with automatic downloads of sources or potentials.
 # Compilation of libraries like Plumed or ScaFaCoS can take a considerable amount of time.
 
-set(ALL_PACKAGES KIM MSCG VORONOI PLUMED SCAFACOS MACHDYN MESONT MDI ML-PACE)
+set(ALL_PACKAGES KIM MSCG VORONOI PLUMED SCAFACOS ALLPKG MACHDYN MESONT MDI ML-PACE)
 
 foreach(PKG ${ALL_PACKAGES})
   set(PKG_${PKG} ON CACHE BOOL "" FORCE)
@@ -14,4 +14,5 @@
 set(DOWNLOAD_PACE ON CACHE BOOL "" FORCE)
 set(DOWNLOAD_PLUMED ON CACHE BOOL "" FORCE)
 set(DOWNLOAD_SCAFACOS ON CACHE BOOL "" FORCE)
+set(DOWNLOAD_ALLPKG ON CACHE BOOL "" FORCE)
 
diff -ruN a/cmake/presets/nolib.cmake b/cmake/presets/nolib.cmake
--- a/cmake/presets/nolib.cmake	2025-11-05 15:55:49.584659777 +0100
+++ b/cmake/presets/nolib.cmake	2025-11-05 16:34:13.458392617 +0100
@@ -3,6 +3,7 @@
 
 set(PACKAGES_WITH_LIB
   ADIOS
+  ALLPKG
   APIP
   ATC
   AWPMD
diff -ruN a/examples/PACKAGES/allpkg/in.balance.2d b/examples/PACKAGES/allpkg/in.balance.2d
--- a/examples/PACKAGES/allpkg/in.balance.2d	1970-01-01 01:00:00.000000000 +0100
+++ b/examples/PACKAGES/allpkg/in.balance.2d	2025-11-05 16:34:26.397151479 +0100
@@ -0,0 +1,64 @@
+# 2d circle of particles inside a box with LJ walls (same like in examples/balance/in.balance)
+
+variable	b index 0
+
+variable	x index 50
+variable	y index 20
+variable	d index 20
+variable	v index 5
+variable	w index 2
+
+units		lj
+dimension	2
+atom_style	atomic
+boundary	f f p
+
+lattice		hex 0.85
+region		box block 0 $x 0 $y -0.5 0.5
+create_box	1 box
+region		circle sphere $(v_d/2+1) $(v_d/2/sqrt(3.0)+1) 0.0 $(v_d/2)
+create_atoms	1 region circle
+mass		1 1.0
+
+velocity	all create 0.5 87287 loop geom
+velocity        all set $v $w 0 sum yes
+
+pair_style	lj/cut 2.5
+pair_coeff	1 1 10.0 1.0 2.5
+
+neighbor	0.3 bin
+neigh_modify	delay 0 every 1 check yes
+
+fix		1 all nve
+
+fix		2 all wall/lj93 xlo 0.0 1 1 2.5 xhi $x 1 1 2.5
+fix		3 all wall/lj93 ylo 0.0 1 1 2.5 yhi $y 1 1 2.5
+
+
+comm_style	staggered zyx # zyx is hard coded for historic reasons (we discussed a variable order of cuts in the past, but then never implemented them in ALL afaik)
+fix		5 all balance/all every 50 grid staggered global 0.9 0.003
+#fix		5 all balance/all every 50 grid staggered weight time 1.0 weight neigh 0.5 global 0.9 0.003 true
+##fix		5 all balance/all every 50 grid staggered load natoms global 0.9 0.003 true
+
+#comm_style	tiled
+#fix		5 all balance 50 0.9 rcb
+
+#comm_style	brick
+#fix		5 all balance/all every 50 grid tensor max weight time 1.0 local 0.9
+##fix		5 all balance/all every 50 grid tensor max load natoms local 0.9
+
+#comm_style	staggered zyx
+#fix		5 all balance/all every 50 grid staggered weight time 1.0 local 1.2 global 1.5 0.003 true
+##fix		5 all balance/all every 50 grid staggered load natoms local 1.2 global 1.5 0.003 true
+
+
+compute		1 all property/atom proc
+variable	p atom c_1%10
+dump		2 all custom 50 /tmp/tmp.dump id v_p x y z
+
+log         balance_all.log
+
+thermo_style	custom step temp epair press f_5[*]
+thermo		100
+
+run		10000
diff -ruN a/examples/PACKAGES/allpkg/in.balance.staggered.global b/examples/PACKAGES/allpkg/in.balance.staggered.global
--- a/examples/PACKAGES/allpkg/in.balance.staggered.global	1970-01-01 01:00:00.000000000 +0100
+++ b/examples/PACKAGES/allpkg/in.balance.staggered.global	2025-11-05 16:34:26.397526613 +0100
@@ -0,0 +1,51 @@
+# 2d circle of particles inside a box with LJ walls (based off examples/balance/in.balance)
+
+variable        b index 0
+
+variable        x index 50
+variable        y index 20
+variable        d index 20
+variable        v index 5
+variable        w index 2
+
+units           lj
+dimension       2
+atom_style      atomic
+boundary        f f p
+
+lattice         hex 0.85
+region          box block 0 $x 0 $y -0.5 0.5
+create_box      1 box
+region          circle sphere $(v_d/2+1) $(v_d/2/sqrt(3.0)+1) 0.0 $(v_d/2)
+create_atoms    1 region circle
+mass            1 1.0
+
+velocity        all create 0.5 87287 loop geom
+velocity        all set $v $w 0 sum yes
+
+pair_style      lj/cut 2.5
+pair_coeff      1 1 10.0 1.0 2.5
+
+neighbor        0.3 bin
+neigh_modify    delay 0 every 1 check yes
+
+fix             1 all nve
+
+fix             2 all wall/lj93 xlo 0.0 1 1 2.5 xhi $x 1 1 2.5
+fix             3 all wall/lj93 ylo 0.0 1 1 2.5 yhi $y 1 1 2.5
+
+
+comm_style      staggered zyx # zyx is hard coded for historic reasons (a variable order of cuts has been discussed but not yet implemented in ALL)
+fix             5 all balance/all every 50 grid staggered global 0.9 0.003
+
+#compute         1 all property/atom proc
+#variable        p atom c_1%10
+#dump            2 all custom 50 /tmp/tmp.dump id v_p x y z
+#
+#log             balance_all.log
+
+thermo_style    custom step temp epair press f_5[*]
+thermo          100
+
+run             10000
+
diff -ruN a/examples/PACKAGES/allpkg/in.balance.staggered.local b/examples/PACKAGES/allpkg/in.balance.staggered.local
--- a/examples/PACKAGES/allpkg/in.balance.staggered.local	1970-01-01 01:00:00.000000000 +0100
+++ b/examples/PACKAGES/allpkg/in.balance.staggered.local	2025-11-05 16:34:26.397892107 +0100
@@ -0,0 +1,51 @@
+# 2d circle of particles inside a box with LJ walls (based off examples/balance/in.balance)
+
+variable        b index 0
+
+variable        x index 50
+variable        y index 20
+variable        d index 20
+variable        v index 5
+variable        w index 2
+
+units           lj
+dimension       2
+atom_style      atomic
+boundary        f f p
+
+lattice         hex 0.85
+region          box block 0 $x 0 $y -0.5 0.5
+create_box      1 box
+region          circle sphere $(v_d/2+1) $(v_d/2/sqrt(3.0)+1) 0.0 $(v_d/2)
+create_atoms    1 region circle
+mass            1 1.0
+
+velocity        all create 0.5 87287 loop geom
+velocity        all set $v $w 0 sum yes
+
+pair_style      lj/cut 2.5
+pair_coeff      1 1 10.0 1.0 2.5
+
+neighbor        0.3 bin
+neigh_modify    delay 0 every 1 check yes
+
+fix             1 all nve
+
+fix             2 all wall/lj93 xlo 0.0 1 1 2.5 xhi $x 1 1 2.5
+fix             3 all wall/lj93 ylo 0.0 1 1 2.5 yhi $y 1 1 2.5
+
+
+comm_style      staggered zyx # zyx is hard coded for historic reasons (a variable order of cuts has been discussed but not yet implemented in ALL)
+fix             5 all balance/all every 50 grid staggered local 0.9
+
+#compute         1 all property/atom proc
+#variable        p atom c_1%10
+#dump            2 all custom 50 /tmp/tmp.dump id v_p x y z
+#
+#log             balance_all.log
+
+thermo_style    custom step temp epair press f_5[*]
+thermo          100
+
+run             10000
+
diff -ruN a/examples/PACKAGES/allpkg/in.balance.tensor.classic b/examples/PACKAGES/allpkg/in.balance.tensor.classic
--- a/examples/PACKAGES/allpkg/in.balance.tensor.classic	1970-01-01 01:00:00.000000000 +0100
+++ b/examples/PACKAGES/allpkg/in.balance.tensor.classic	2025-11-05 16:34:26.398231161 +0100
@@ -0,0 +1,51 @@
+# 2d circle of particles inside a box with LJ walls (based off examples/balance/in.balance)
+
+variable        b index 0
+
+variable        x index 50
+variable        y index 20
+variable        d index 20
+variable        v index 5
+variable        w index 2
+
+units           lj
+dimension       2
+atom_style      atomic
+boundary        f f p
+
+lattice         hex 0.85
+region          box block 0 $x 0 $y -0.5 0.5
+create_box      1 box
+region          circle sphere $(v_d/2+1) $(v_d/2/sqrt(3.0)+1) 0.0 $(v_d/2)
+create_atoms    1 region circle
+mass            1 1.0
+
+velocity        all create 0.5 87287 loop geom
+velocity        all set $v $w 0 sum yes
+
+pair_style      lj/cut 2.5
+pair_coeff      1 1 10.0 1.0 2.5
+
+neighbor        0.3 bin
+neigh_modify    delay 0 every 1 check yes
+
+fix             1 all nve
+
+fix             2 all wall/lj93 xlo 0.0 1 1 2.5 xhi $x 1 1 2.5
+fix             3 all wall/lj93 ylo 0.0 1 1 2.5 yhi $y 1 1 2.5
+
+
+comm_style      brick
+fix             5 all balance/all every 50 grid tensor classic local 0.9
+
+#compute         1 all property/atom proc
+#variable        p atom c_1%10
+#dump            2 all custom 50 /tmp/tmp.dump id v_p x y z
+#
+#log             balance_all.log
+
+thermo_style    custom step temp epair press f_5[*]
+thermo          100
+
+run             10000
+
diff -ruN a/examples/PACKAGES/allpkg/in.balance.tensor.max b/examples/PACKAGES/allpkg/in.balance.tensor.max
--- a/examples/PACKAGES/allpkg/in.balance.tensor.max	1970-01-01 01:00:00.000000000 +0100
+++ b/examples/PACKAGES/allpkg/in.balance.tensor.max	2025-11-05 16:34:26.398879118 +0100
@@ -0,0 +1,51 @@
+# 2d circle of particles inside a box with LJ walls (based off examples/balance/in.balance)
+
+variable        b index 0
+
+variable        x index 50
+variable        y index 20
+variable        d index 20
+variable        v index 5
+variable        w index 2
+
+units           lj
+dimension       2
+atom_style      atomic
+boundary        f f p
+
+lattice         hex 0.85
+region          box block 0 $x 0 $y -0.5 0.5
+create_box      1 box
+region          circle sphere $(v_d/2+1) $(v_d/2/sqrt(3.0)+1) 0.0 $(v_d/2)
+create_atoms    1 region circle
+mass            1 1.0
+
+velocity        all create 0.5 87287 loop geom
+velocity        all set $v $w 0 sum yes
+
+pair_style      lj/cut 2.5
+pair_coeff      1 1 10.0 1.0 2.5
+
+neighbor        0.3 bin
+neigh_modify    delay 0 every 1 check yes
+
+fix             1 all nve
+
+fix             2 all wall/lj93 xlo 0.0 1 1 2.5 xhi $x 1 1 2.5
+fix             3 all wall/lj93 ylo 0.0 1 1 2.5 yhi $y 1 1 2.5
+
+
+comm_style      brick
+fix             5 all balance/all every 50 grid tensor max local 0.9
+
+#compute         1 all property/atom proc
+#variable        p atom c_1%10
+#dump            2 all custom 50 /tmp/tmp.dump id v_p x y z
+#
+#log             balance_all.log
+
+thermo_style    custom step temp epair press f_5[*]
+thermo          100
+
+run             10000
+
diff -ruN a/examples/PACKAGES/allpkg/README b/examples/PACKAGES/allpkg/README
--- a/examples/PACKAGES/allpkg/README	1970-01-01 01:00:00.000000000 +0100
+++ b/examples/PACKAGES/allpkg/README	2025-11-05 16:34:26.393337166 +0100
@@ -0,0 +1,8 @@
+The `balance/all` fix is more or less a drop-in replacement for the `balance` fix provided by LAMMPS.
+
+It supports two main decomposition methods 'staggered' and 'tensor'.
+The 'tensor' decomposition exists in two variants, one minimizing the average load of the system ('tensor classic') and one minimizing the maximal load of the system ('tensor max').
+
+For staggered decomposition you can choose to balance locally or globally (aka Histogram), while tensor decomposition only supports local balancing.
+
+Just like `balance`, `balance/all` supports all the `weight` options.
diff -ruN a/lib/allpkg/.gitignore b/lib/allpkg/.gitignore
--- a/lib/allpkg/.gitignore	1970-01-01 01:00:00.000000000 +0100
+++ b/lib/allpkg/.gitignore	2025-11-05 16:36:29.369380195 +0100
@@ -0,0 +1,4 @@
+/loadbalancing*
+/include
+/lib
+/build
diff -ruN a/lib/allpkg/Install.py b/lib/allpkg/Install.py
--- a/lib/allpkg/Install.py	1970-01-01 01:00:00.000000000 +0100
+++ b/lib/allpkg/Install.py	2025-11-05 16:36:29.370064000 +0100
@@ -0,0 +1,132 @@
+#!/usr/bin/env python
+
+"""
+Install.py tool to download, unpack, build, and link to the ALL library
+used to automate the steps described in the README file in this dir
+"""
+
+from __future__ import print_function
+import sys, os, subprocess, shutil, tarfile
+from argparse import ArgumentParser
+
+sys.path.append('..')
+from install_helpers import fullpath, geturl, get_cpus, checkmd5sum, getfallback
+
+parser = ArgumentParser(prog='Install.py', description="LAMMPS library build wrapper script")
+
+# settings
+
+version = "0.9.3"
+
+# known md5 checksums for different ALL versions. used to validate the download.
+checksums = {
+        '0.9.2' : '2fcc8bcb60f33fa0369e8f44a5c4b884',
+        '0.9.3' : '9fc008711a7dfaf35e957411f8ed1504'
+        }
+
+# extra help message
+
+HELP = """
+Syntax from src dir: make lib-allpkg args="-b"
+                 or: make lib-allpkg args="-p /path/to/ALL"
+Syntax from lib dir: python Install.py -b
+                 or: python Install.py -p /path/to/ALL
+
+Example:
+
+make lib-allpkg args="-b"   # download/build in lib/allpkg/ALL
+make lib-allpkg args="-p $HOME/ALL" # use existing ALL installation in $HOME
+"""
+
+# parse and process arguments
+
+pgroup = parser.add_mutually_exclusive_group()
+pgroup.add_argument("-b", "--build", action="store_true",
+                    help="download and build the ALL library")
+pgroup.add_argument("-p", "--path",
+                    help="specify folder of existing ALL installation")
+parser.add_argument("-v", "--version", default=version,
+                    help="set version of ALL to download and build (default: %s)" % version)
+
+args = parser.parse_args()
+
+# print help message and exit, if neither build nor path options are given
+if not args.build and not args.path:
+  parser.print_help()
+  sys.exit(HELP)
+
+buildflag = args.build
+pathflag = args.path is not None
+version = args.version
+url = "https://gitlab.jsc.fz-juelich.de/SLMS/loadbalancing/-/archive/v%s/loadbalancing-v%s.tar.gz" % (version, version)
+
+
+homepath = fullpath(".")
+ALL_path = os.path.join(homepath, "loadbalancing-v%s" % version)
+
+if pathflag:
+  ALL_path = args.path
+  if not os.path.isdir(os.path.join(ALL_path, "include")):
+    sys.exit("ALL include path for %s does not exist" % ALL_path)
+  if (not os.path.isdir(os.path.join(ALL_path, "lib64"))) \
+     and (not os.path.isdir(os.path.join(ALL_path, "lib"))):
+    sys.exit("ALL lib path for %s does not exist" % ALL_path)
+  ALL_path = fullpath(ALL_path)
+
+# download and unpack ALL tarball
+
+if buildflag:
+  print("Downloading ALL ...")
+  filename = "%s/loadbalancing-v%s.tar.gz" % (homepath, version)
+  fallback = getfallback('loadbalancing', url)
+  try:
+    geturl(url, filename)
+  except:
+    geturl(fallback, filename)
+
+  # verify downloaded archive integrity via md5 checksum, if known.
+  if version in checksums:
+    if not checkmd5sum(checksums[version], filename):
+      print("Checksum did not match. Trying fallback URL", fallback)
+      geturl(fallback, filename)
+      if not checkmd5sum(checksums[version], filename):
+        sys.exit("Checksum for ALL library does not match for fallback, too.")
+
+  print("Unpacking ALL tarball ...")
+  if os.path.exists(ALL_path):
+    shutil.rmtree(ALL_path)
+  tarname = os.path.join(homepath, "%s.tar.gz" % ALL_path)
+  if tarfile.is_tarfile(tarname):
+    tgz = tarfile.open(tarname)
+    tgz.extractall(path=homepath)
+    os.remove(tarname)
+  else:
+    sys.exit("File %s is not a supported archive" % tarname)
+
+  # build ALL
+  print("Building ALL ...")
+  n_cpu = get_cpus()
+  build_dir = os.path.join(homepath, 'build')
+  cmd = 'gotoCleanDir() { test -d $1 && rm -r $1 ; mkdir -p $1 ; cd $1 ; } ; gotoCleanDir "%s" ; cmake "%s" ; cmake --build ./ --parallel "%d" && cmake --install ./ --prefix ./' % (build_dir, ALL_path, n_cpu)
+  try:
+    txt = subprocess.check_output(cmd, stderr=subprocess.STDOUT, shell=True)
+    print(txt.decode('UTF-8'))
+  except subprocess.CalledProcessError as e:
+    sys.exit("CMake failed with:\n %s" % e.output.decode('UTF-8'))
+
+# create 2 links in lib/allpkg to ALL include/lib dirs
+
+print("Creating links to ALL include and lib files")
+if os.path.isfile("include") or os.path.islink("include"):
+  os.remove("include")
+if os.path.isfile("lib") or os.path.islink("lib"):
+  os.remove("lib")
+if buildflag:
+  os.symlink(os.path.join(homepath, 'build', 'include'), 'include')
+  os.symlink(os.path.join(homepath, 'build', 'lib'), 'lib')
+else:
+  os.symlink(os.path.join(ALL_path, 'include'), 'include')
+  if os.path.isdir(os.path.join(ALL_path, "lib64")):
+    os.symlink(os.path.join(ALL_path, 'lib64'), 'lib')
+  else:
+    os.symlink(os.path.join(ALL_path, 'lib'), 'lib')
diff -ruN a/lib/allpkg/README b/lib/allpkg/README
--- a/lib/allpkg/README	1970-01-01 01:00:00.000000000 +0100
+++ b/lib/allpkg/README	2025-11-05 16:36:29.370429147 +0100
@@ -0,0 +1,42 @@
+A Load Balancing Library (ALL):
+
+-----------------
+
+The library aims to provide an easy way to include dynamic domain-based
+load balancing into particle based simulation codes. The library is
+developed in the Simulation Laboratory Molecular Systems of the Jlich
+Supercomputing Centre at Forschungszentrum Jlich. 
+
+-----------------
+
+Requirements:
+    Base:
+        - C++11 capable compiler
+        - MPI support
+        - CMake v. 3.14 or higher
+    Optional:
+        - Fortran 2003 capable compiler (Fortran interface)
+        - Fortran 2008 capable compiler (Usage of the `mpi_f08` interface)
+        - VTK 7.1 or higher (Domain output)
+        - Boost testing utilities
+        - Doxygen and Sphinx with `breathe` (Documentation)
+
+-----------------
+
+Installation:
+
+    1.) Clone the library from https://gitlab.jsc.fz-juelich.de/SLMS/loadbalancing
+        into `$ALL_ROOT_DIR`.
+    2.) Create the build directory `$ALL_BUILD_DIR` some place else.
+    3.) Call 
+            cmake -S "$ALL_ROOT_DIR" -B "$ALL_BUILD_DIR"
+        to set up the installation.
+        To use a specific compiler and Boost installation use:
+            CC=gcc CXX=g++ BOOST_ROOT=$BOOST_DIR cmake [...]
+    4.) To build and install the library then run:
+            cmake --build "$ALL_BUILD_DIR"
+            cmake --install "$ALL_BUILD_DIR" --prefix "$ALL_INSTALL_DIR"
+        Afterwards, the built examples and library files are placed in
+        `$ALL_INSTALL_DIR`.
+
+-----------------
diff -ruN a/src/ALLPKG/fix_balance_all.cpp b/src/ALLPKG/fix_balance_all.cpp
--- a/src/ALLPKG/fix_balance_all.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/src/ALLPKG/fix_balance_all.cpp	2025-11-05 16:36:36.437335000 +0100
@@ -0,0 +1,870 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "fix_balance_all.h"
+
+#include "ALL.hpp"
+
+#include "timer.h"
+#include "pointers.h"
+#include "pair.h"
+#include "fix_store_atom.h"
+
+#include "atom.h"
+#include "comm.h"
+#include "domain.h"
+#include "error.h"
+#include "force.h"
+#include "group.h"
+#include "imbalance.h"
+#include "imbalance_group.h"
+#include "imbalance_neigh.h"
+#include "imbalance_store.h"
+#include "imbalance_time.h"
+#include "imbalance_var.h"
+#include "irregular.h"
+#include "kspace.h"
+#include "modify.h"
+#include "neighbor.h"
+#include "memory.h"
+#include "update.h"
+
+#include <cstring>
+#include <mpi.h>
+#include <math.h>
+
+using namespace LAMMPS_NS;
+using namespace FixConst;
+
+enum { TENSOR, STAGGERED, UNKNOWN_GRID };
+enum { TENSOR_MAX, TENSOR_CLASSIC, NONE };
+
+// clang-format off
+
+/**
+ *  create class and parse arguments in LAMMPS script.
+ *  Syntax:
+ *
+ *  fix ID group-ID balance/all keyword args ...
+ *
+ *  required keyword/arg pairs
+ *
+ *      every arg = nevery
+ *          nevery = perform dynamic load balancing every this many steps
+ *      grid style args = define grid
+ *          style = staggered or tensor
+ *              staggered args = none
+ *              tensor args = max or classic
+ *                max = use TENSOR_MAX method of ALL
+ *                classic = use TENSOR method of ALL
+ *
+ *      weight style args = use weighted particle counts for the balancing
+ *          style = group or neigh or time or var or store
+ *              group args = Ngroup group1 weight1 group2 weight2 ...
+ *                Ngroup = number of groups with assigned weights
+ *                group1, group2, ... = group IDs
+ *                weight1, weight2, ...   = corresponding weight factors
+ *              neigh factor = compute weight based on number of neighbors
+ *                factor = scaling factor (> 0)
+ *              time factor = compute weight based on time spend computing
+ *                factor = scaling factor (> 0)
+ *              var name = take weight from atom-style variable
+ *                name = name of the atom-style variable
+ *              store name = store weight in custom atom property defined by fix property/atom command
+ *                name = atom property name (without d_ prefix)
+ *
+ *  At least one of the following keyword/arg pairs is required.
+ *  Only one (or none) load balancer is used in a load balancing step.
+ *
+ *      global args = trigger_threshold bin_width (use histogram balancing; only for staggered)
+ *          trigger_threshold = float
+ *              float = apply load balancer if the imbalance of the load is above this threshold
+ *          bin_width = approximate width of bin (arbitrary positive value)
+ *      local args = trigger_threshold (use local balancing)
+ *          trigger_threshold = float
+ *              float = apply load balancer if the imbalance of the load is above this threshold
+ *
+ *  optional keyword arg pairs
+ *
+ *      verbose args = none (verbose output to log/screen)
+ */
+
+FixBalanceAll::FixBalanceAll(LAMMPS *lmp, int narg, char **arg) :
+  Fix(lmp, narg, arg), all_local(nullptr), irregular(nullptr), all_global(nullptr)
+{
+  if (narg < 6) error->all(FLERR,"Illegal fix balance/all command");
+
+  imbalances = nullptr;
+  fixstore = nullptr;
+
+  box_change = BOX_CHANGE_DOMAIN;
+  pre_exchange_migrate = 1;
+
+  vector_flag = 1;
+  size_vector = 6;
+  extvector = 0;
+
+  // parse required arguments
+
+  if (domain->triclinic) error->all(FLERR,"triclinic domains are not yet supported by ALL");
+
+  // set defaul values
+
+  gridstyle = UNKNOWN_GRID;
+  int tensorstyle = NONE;
+  nevery = -1;
+  bw = -1;
+  local_threshold = -1;
+  global_threshold = -1;
+  use_local_lb = false;
+  use_global_lb = false;
+  verbose = false;
+  wtflag = 0;
+  varflag = 0;
+
+  // count max number of weight settings
+
+  nimbalance = 0;
+  for (int i = 3; i < narg; i++)
+    if (strcmp(arg[i],"weight") == 0) nimbalance++;
+  if (nimbalance) imbalances = new Imbalance*[nimbalance];
+  nimbalance = 0;
+
+  // parse arguments
+  for (int iarg = 3; iarg < narg; ++iarg) {
+    if (strcmp(arg[iarg],"every") == 0) {
+      if (iarg+1 >= narg) error->all(FLERR, "balance/all: every requires an integer");
+      nevery = utils::inumeric(FLERR,arg[iarg+1],false,lmp);
+      iarg++;
+    } else if (strcmp(arg[iarg],"grid") == 0) {
+      if (iarg+1 >= narg) error->all(FLERR, "balance/all: grid requires one argument");
+      if (gridstyle != UNKNOWN_GRID) error->all(FLERR, "balance/all: multiple grid styles defined");
+      if (strcmp(arg[iarg+1],"staggered") == 0) gridstyle = STAGGERED;
+      else if (strcmp(arg[iarg+1],"tensor") == 0) {
+        gridstyle = TENSOR;
+        if (iarg+2 >= narg) error->all(FLERR, "balance/all: grid tensor requires one argument");
+        if (strcmp(arg[iarg+2],"classic") == 0) tensorstyle = TENSOR_CLASSIC;
+        else if (strcmp(arg[iarg+2],"max") == 0) tensorstyle = TENSOR_MAX;
+        else error->all(FLERR, "balance/all: unknown grid tensor argument {}", arg[iarg+2]);
+        iarg++;
+      } else error->all(FLERR, "balance/all: unknown grid argument {}", arg[iarg+1]);
+      iarg++;
+    } else if (strcmp(arg[iarg],"weight") == 0) {
+      wtflag = 1;
+      Imbalance *imb;
+      int nopt = 0;
+      if (strcmp(arg[iarg+1],"group") == 0) {
+        imb = new ImbalanceGroup(lmp);
+        nopt = imb->options(narg-iarg,arg+iarg+2);
+        imbalances[nimbalance++] = imb;
+      } else if (strcmp(arg[iarg+1],"time") == 0) {
+        imb = new ImbalanceTime(lmp);
+        nopt = imb->options(narg-iarg,arg+iarg+2);
+        imbalances[nimbalance++] = imb;
+      } else if (strcmp(arg[iarg+1],"neigh") == 0) {
+        imb = new ImbalanceNeigh(lmp);
+        nopt = imb->options(narg-iarg,arg+iarg+2);
+        imbalances[nimbalance++] = imb;
+      } else if (strcmp(arg[iarg+1],"var") == 0) {
+        varflag = 1;
+        imb = new ImbalanceVar(lmp);
+        nopt = imb->options(narg-iarg,arg+iarg+2);
+        imbalances[nimbalance++] = imb;
+      } else if (strcmp(arg[iarg+1],"store") == 0) {
+        imb = new ImbalanceStore(lmp);
+        nopt = imb->options(narg-iarg,arg+iarg+2);
+        imbalances[nimbalance++] = imb;
+      } else {
+        error->all(FLERR,"Unknown fix balance/all weight method: {}", arg[iarg+1]);
+      }
+      iarg += 1+nopt;
+    } else if (strcmp(arg[iarg],"verbose") == 0) {
+      verbose = true;
+    } else if (strcmp(arg[iarg],"global") == 0) {
+      if (iarg+2 >= narg) error->all(FLERR, "balance/all: histogram requires two arguments");
+      use_global_lb = true;
+      global_threshold = utils::numeric(FLERR,arg[iarg+1],false,lmp);
+      bw = utils::numeric(FLERR,arg[iarg+2],false,lmp);
+      iarg += 2;
+    } else if (strcmp(arg[iarg],"local") == 0) {
+      if (iarg+1 >= narg) error->all(FLERR, "balance/all: threshold requires one argument");
+      use_local_lb = true;
+      local_threshold = utils::numeric(FLERR,arg[iarg+1],false,lmp);
+      iarg++;
+    } else error->all(FLERR,"balance/all: unknown argument '{}'", arg[iarg]);
+  }
+
+  // check arguments
+  if (nevery < 1) error->all(FLERR,"balance/all: nevery > 0 required");
+  if (gridstyle == UNKNOWN_GRID) error->all(FLERR, "balance/all: grid style required");
+  if (use_global_lb) {
+    if (gridstyle != STAGGERED) error->all(FLERR, "balance/all: histogram requires staggered grid");
+    if (bw <= 0) error->all(FLERR, "balance/all: bw not positive");
+  }
+  if (! (use_local_lb || use_global_lb)) error->all(FLERR, "balance/all: at least local, global required");
+  if (use_local_lb && use_global_lb) {
+    if (local_threshold >= global_threshold) error->all(FLERR, "balance/all: local threshold < global threshold required");
+  }
+
+  // set comm style dependent on gridstyle ? see Input::comm_style()
+  // probably not since there is no running simulation in input (in contrast to here)
+  if (gridstyle == STAGGERED && comm->style != 2)
+    error->all(FLERR,"balance/all: comm_style staggered required for staggered grid");
+  if (gridstyle == TENSOR && comm->style != 0)
+    error->all(FLERR,"balance/all: comm_style brick required for tensor grid");
+
+  if (gridstyle == STAGGERED) {
+    all_local = new ALL::ALL<double, double>(ALL::STAGGERED, 3, 0);
+  } else if (gridstyle == TENSOR) {
+    if (tensorstyle == TENSOR_MAX) all_local = new ALL::ALL<double, double>(ALL::TENSOR_MAX, 3, 0);
+    else if (tensorstyle == TENSOR_CLASSIC) all_local = new ALL::ALL<double, double>(ALL::TENSOR, 3, 0);
+  }
+
+  if (use_global_lb) {
+    all_global = new ALL::ALL<double, double>(ALL::HISTOGRAM, 3, 0);
+    n_bins = std::vector<int>(3, -1);
+  }
+
+  all_last = nullptr;
+
+  global_freq = 1; // nevery;
+
+  irregular = new Irregular(lmp);
+
+  x_masters = MPI_COMM_NULL;
+  y_masters = MPI_COMM_NULL;
+  z_masters = MPI_COMM_NULL;
+
+  timer_lb = imbalance = maxloadperproc = -1;
+
+  force_reneighbor = 1;
+  lastbalance = -1;
+  next_reneighbor = -1;
+
+  reduce_outvec_flag = false;
+  for (int i = 0; i < 3; ++i) outvec_timer[i] = -1;
+}
+
+/**
+ *  Deconstructor. Free communicators and delete allocated memory.
+ */
+
+FixBalanceAll::~FixBalanceAll()
+{
+  all_last = nullptr;
+  if (all_local) delete all_local;
+  if (all_global) delete all_global;
+  delete irregular;
+
+  if (x_masters != MPI_COMM_NULL) MPI_Comm_free(&x_masters);
+  if (y_masters != MPI_COMM_NULL) MPI_Comm_free(&y_masters);
+  if (z_masters != MPI_COMM_NULL) MPI_Comm_free(&z_masters);
+
+  for (int i = 0; i < nimbalance; i++) delete imbalances[i];
+  delete[] imbalances;
+
+  // check nfix in case all fixes have already been deleted
+  if (fixstore && modify->nfix) modify->delete_fix(fixstore->id);
+  fixstore = nullptr;
+
+}
+
+/**
+ *  Post constructor. Setup weight storage.
+ */
+
+void FixBalanceAll::post_constructor()
+{
+  if (wtflag) weight_storage();
+}
+
+/**
+ *  For lammps. This fix is just called in pre_exchange.
+ *  @return mask
+ */
+
+int FixBalanceAll::setmask()
+{
+  int mask = 0;
+  mask |= PRE_EXCHANGE;
+  return mask;
+}
+
+/**
+ *  Initialise calculated variables and setup ALL objects.
+ *  Setup initial grid.
+ *  Write information to log.
+ */
+
+void FixBalanceAll::init()
+{
+  // called before every run
+
+  int counter = 0;
+  for (int i=0; i<modify->nfix; i++) {
+    if (strcmp(modify->fix[i]->style, "balance") == 0) counter++;
+    if (strcmp(modify->fix[i]->style, "balance/all") == 0) counter++;
+  }
+  if (counter > 1) error->all(FLERR, "More than one dynamic load balancing fix");
+
+  // get vectors as input for ALL
+
+  // use existing uniform grid
+  if (comm->layout == Comm::LAYOUT_TILED) error->all(FLERR, "balance/all: initialisation from Comm::LAYOUT_TILED not possible.");
+  if (comm->layout == Comm::LAYOUT_STAGGERED && gridstyle == TENSOR) error->all(FLERR, "balance/all: initialisation from Comm::STAGGERED not possible.");
+  if (gridstyle == STAGGERED && comm->style == 2 && (comm->staggered2spatial[0]!=2 || comm->staggered2spatial[1]!=1 || comm->staggered2spatial[2]!=0))
+    error->all(FLERR, "balance/all: comm_style staggered not zyx");
+  if (domain->dimension == 2 && comm->procgrid[2] != 1) error->all(FLERR,"balance/all: 2D-simulation not possible with {} processors in z-direction", comm->procgrid[2]);
+  procgrid_vec.assign(comm->procgrid, comm->procgrid+3);
+  myloc_vec.assign(comm->myloc, comm->myloc+3);
+
+  minimum_domain_size = {neighbor->skin, neighbor->skin, neighbor->skin};
+
+  // setup ALL
+
+  if (use_local_lb) {
+    all_local->setProcGridParams(myloc_vec, procgrid_vec);
+    all_local->setMinDomainSize(minimum_domain_size);
+    all_local->setCommunicator(world);
+    all_local->setProcTag(comm->me);
+    all_local->setup();
+  }
+
+  if (use_global_lb) {
+    all_global->setProcGridParams(myloc_vec, procgrid_vec);
+    all_global->setMinDomainSize(minimum_domain_size);
+    all_global->setCommunicator(world);
+    all_global->setProcTag(comm->me);
+    all_global->setup();
+  }
+
+  init_imbalance(1);
+
+  // create communicators for tensor
+  if (gridstyle == TENSOR) {
+    int color;
+    // There would be a way to create the communicator without communication, but split is easier to implement.
+
+    if (x_masters != MPI_COMM_NULL) MPI_Comm_free(&x_masters);
+    color = (myloc_vec[1] == 0 && myloc_vec[2] == 0) ? 0 : MPI_UNDEFINED;
+    MPI_Comm_split(world, color, myloc_vec[0], &x_masters);
+
+    if (y_masters != MPI_COMM_NULL) MPI_Comm_free(&y_masters);
+    color = (myloc_vec[0] == 0 && myloc_vec[2] == 0) ? 0 : MPI_UNDEFINED;
+    MPI_Comm_split(world, color, myloc_vec[1], &y_masters);
+
+    if (z_masters != MPI_COMM_NULL) MPI_Comm_free(&z_masters);
+    color = (myloc_vec[0] == 0 && myloc_vec[1] == 0) ? 0 : MPI_UNDEFINED;
+    MPI_Comm_split(world, color, myloc_vec[1], &z_masters);
+  }
+
+  next_reneighbor = (update->ntimestep/nevery)*nevery + nevery;
+
+  if (comm->me == 0) {
+    utils::logmesg(lmp, "ALL information ...\n");
+    utils::logmesg(lmp, "\tversion: 0.9.3\n");
+    if (gridstyle == STAGGERED) utils::logmesg(lmp, "\tgrid: staggered\n");
+    else if (gridstyle == TENSOR) utils::logmesg(lmp, "\tgrid: tensor\n");
+    utils::logmesg(lmp, "\tnumber of processors: {} x {} y {} z\n", procgrid_vec[0], procgrid_vec[1], procgrid_vec[2]);
+    if (use_global_lb) {
+      utils::logmesg(lmp, "\tglobal load balancing ...\n");
+      utils::logmesg(lmp, "\t\ttrigger threshold: {}\n", global_threshold);
+      utils::logmesg(lmp, "\t\tbin width: {}\n", bw);
+    }
+    if (use_local_lb) {
+      utils::logmesg(lmp, "\tlocal load balancing ...\n");
+      utils::logmesg(lmp, "\t\ttrigger threshold: {}\n", local_threshold);
+    }
+    if (verbose) utils::logmesg(lmp, "\tverbose output is used\n");
+  }
+}
+
+/**
+ *  Perform dynamic load balancing if required.
+ *  Calls corresponding local or global balancing function.
+ */
+
+void FixBalanceAll::pre_exchange()
+{
+  // return if not a rebalance timestep
+
+  if (update->ntimestep < next_reneighbor) return;
+
+  // next timestep to rebalance
+  next_reneighbor = (update->ntimestep/nevery)*nevery + nevery;
+
+  balance();
+}
+
+/**
+ *  Perform load balancing.
+ *  Calls corresponding local or global balancing function.
+ */
+
+void FixBalanceAll::balance()
+{
+  // do not allow rebalancing twice on same timestep
+  // even if you wanted to, it can mess up elapsed time
+
+  if (update->ntimestep == lastbalance) return;
+  lastbalance = update->ntimestep;
+
+  double timer_lb_start = platform::walltime();
+
+  set_weights();
+
+  work = get_work();
+
+  calc_imbalance();
+
+  // call load-balancing function if required
+  if (use_global_lb && imbalance > global_threshold)
+    balance_global();
+  else if (use_local_lb && imbalance > local_threshold)
+    balance_local();
+  else {
+    if (verbose && comm->me == 0) utils::logmesg(lmp, "balance/all: {} no balance required\n", imbalance);
+    all_last = nullptr;
+  }
+  unset_weights();
+
+  timer_lb = platform::walltime() - timer_lb_start;
+  reduce_outvec_flag = true;
+}
+
+/**
+ *  Perform staggered/tensor load balancing.
+ */
+
+void FixBalanceAll::balance_local()
+{
+  if (verbose && comm->me == 0) utils::logmesg(lmp, "balance/all: {} balance local\n", imbalance);
+
+  all_last = all_local;
+
+  // ensure atoms are in current box & update box via shrink-wrap
+  // no exchange() since doesn't matter if atoms are assigned to correct procs
+
+  domain->pbc();
+  domain->reset_box();
+
+  // The domain size is changed by adjusting the domain specific variables in comm.h
+  // local box is set with
+  // comm->{xsplit ysplit zsplit myloc procgrid} for tensor
+  // comm->mysplit                               for staggered
+
+  // rebalance with ALL
+  my_vertices = get_comm_vertices();
+  all_local->setVertices(my_vertices);
+  all_local->setWork(work);
+  all_local->balance();
+
+  set_comm_vertices(all_local->getVertices());
+  domain->set_local_box();
+
+  // not required since the minimum box size is also passed to all
+  // domain->subbox_too_small_check(neighbor->skin);
+
+  if (gridstyle == STAGGERED) irregular->migrate_atoms();
+  else if (irregular->migrate_check()) irregular->migrate_atoms();
+
+  modify->reset_grid();
+  if (force->pair) force->pair->reset_grid();
+  if (force->kspace) force->kspace->reset_grid();
+}
+
+/**
+ *  Perform histogram load balancing in z, y and x.
+ */
+
+void FixBalanceAll::balance_global()
+{
+  if (verbose && comm->me == 0) utils::logmesg(lmp, "balance/all: {} balance global\n", imbalance);
+
+  all_last = all_global;
+
+  // only for staggered
+  // histogram method
+
+  // insure atoms are in current box & update box via shrink-wrap
+  // no exchange() since doesn't matter if atoms are assigned to correct procs
+
+  domain->pbc();
+  domain->reset_box();
+
+  // processors may not have complex/simple particles yet, but get some during layer-balancing
+  // -> calculate global average
+  // only once since timers are evaluated
+
+  // atoms should be inside of the boundaries for the histogram calculation
+  irregular->migrate_atoms();
+
+  for (int dim_balance=2; dim_balance>=0; dim_balance--) {
+    // rebalance with ALL
+    my_vertices = get_comm_vertices();
+    all_global->setVertices(my_vertices);
+    all_global->setSysSize(get_sys_size_from_domain());
+
+    all_global->setWork(calc_histogram(dim_balance));
+    all_global->setMethodData(n_bins.data());
+
+    all_global->balance();
+    set_comm_vertices(all_global->getVertices());
+
+    domain->set_local_box();
+
+    irregular->migrate_atoms();
+  }
+
+  modify->reset_grid();
+  if (force->pair) force->pair->reset_grid();
+  if (force->kspace) force->kspace->reset_grid();
+
+}
+
+/**
+ *  Get the size of the simulation box from the domain class.
+ *  @return box size in box units with box origin in 0,0,0
+ */
+
+std::vector<double> FixBalanceAll::get_sys_size_from_domain()
+{
+  std::vector<double> sys_size(6);
+  sys_size.at(0) = 0;
+  sys_size.at(1) = domain->xprd;
+  sys_size.at(2) = 0;
+  sys_size.at(3) = domain->yprd;
+  sys_size.at(4) = 0;
+  sys_size.at(5) = domain->zprd;
+  return sys_size;
+}
+
+/**
+ *  Get size of this domain from class domain for setVertices of ALL.
+ *  @return size of this domain in ALL format
+ */
+
+std::vector<ALL::Point<double>> FixBalanceAll::get_comm_vertices()
+{
+  std::vector<ALL::Point<double>> vertices(2, ALL::Point<double>(3));
+  // comm stores the values in reduced coordinates in [0,1]
+  // -> multiply with box length per dimension
+  if (comm->layout == Comm::LAYOUT_STAGGERED) {
+    // tiled
+    vertices[0][0] = comm->mysplit[0][0] * domain->prd[0];
+    vertices[0][1] = comm->mysplit[1][0] * domain->prd[1];
+    vertices[0][2] = comm->mysplit[2][0] * domain->prd[2];
+    vertices[1][0] = comm->mysplit[0][1] * domain->prd[0];
+    vertices[1][1] = comm->mysplit[1][1] * domain->prd[1];
+    vertices[1][2] = comm->mysplit[2][1] * domain->prd[2];
+  } else {
+    // uniform
+    vertices[0][0] = comm->xsplit[comm->myloc[0]] * domain->prd[0];
+    vertices[0][1] = comm->ysplit[comm->myloc[1]] * domain->prd[1];
+    vertices[0][2] = comm->zsplit[comm->myloc[2]] * domain->prd[2];
+    vertices[1][0] = comm->xsplit[comm->myloc[0]+1] * domain->prd[0];
+    vertices[1][1] = comm->ysplit[comm->myloc[1]+1] * domain->prd[1];
+    vertices[1][2] = comm->zsplit[comm->myloc[2]+1] * domain->prd[2];
+  }
+
+  return vertices;
+}
+
+/**
+ *  Get load of this domain for imbalance calculation and setWork of
+ *  local ALL object.
+ *  @return work according to used definition
+ */
+
+double FixBalanceAll::get_work()
+{
+  double work = 0.0;
+
+  if (wtflag) {
+    weight = fixstore->vstore;
+    int nlocal = atom->nlocal;
+    for (int i = 0; i < nlocal; i++)
+      work += weight[i];
+
+  } else {
+    work = atom->nlocal;
+  }
+
+  return work;
+}
+
+/**
+ *  Set domain boundaries in class comm for tiled or brick layout.
+ *  @param[in] vertices returned by ALL object after load balancing step
+ *  @note updates layout, staggerednew, mysplit for staggered
+ *  @note updates xsplit, ysplit, zsplit for tensor
+ */
+
+void FixBalanceAll::set_comm_vertices(std::vector<ALL::Point<double>> vertices)
+{
+  if (gridstyle == STAGGERED) {
+    // set tiled values
+    comm->layout = Comm::LAYOUT_STAGGERED;
+    // comm stores the values in reduced coordinates in [0,1]
+    // -> divide by box length
+    comm->staggerednew = 1;
+
+    // just get the vertices
+    comm->mysplit[0][0] = vertices[0][0] / domain->prd[0];
+    comm->mysplit[1][0] = vertices[0][1] / domain->prd[1];
+    comm->mysplit[2][0] = vertices[0][2] / domain->prd[2];
+    comm->mysplit[0][1] = vertices[1][0] / domain->prd[0];
+    comm->mysplit[1][1] = vertices[1][1] / domain->prd[1];
+    comm->mysplit[2][1] = vertices[1][2] / domain->prd[2];
+
+    // prevention of floating point issues
+    for (int idim=0; idim<3; idim++) {
+      if (myloc_vec[idim] == 0) comm->mysplit[idim][0] = 0;
+      if (myloc_vec[idim] == procgrid_vec[idim]-1) comm->mysplit[idim][1] = 1;
+    }
+
+  } else {
+    // gridstyle == TENSOR
+
+    // rescale to [0:1]
+    vertices[1][0] /= domain->prd[0];
+    vertices[1][1] /= domain->prd[1];
+    vertices[1][2] /= domain->prd[2];
+
+    // xsplit ysplit zsplit contain all values
+    // split[0] is not changed, but it is zero anyway
+    // gather all upper boundaries on master
+    if (x_masters != MPI_COMM_NULL) MPI_Gather(&(vertices[1][0]), 1, MPI_DOUBLE, comm->xsplit+1, 1, MPI_DOUBLE, 0, x_masters);
+    if (y_masters != MPI_COMM_NULL) MPI_Gather(&(vertices[1][1]), 1, MPI_DOUBLE, comm->ysplit+1, 1, MPI_DOUBLE, 0, y_masters);
+    if (z_masters != MPI_COMM_NULL) MPI_Gather(&(vertices[1][2]), 1, MPI_DOUBLE, comm->zsplit+1, 1, MPI_DOUBLE, 0, z_masters);
+
+    // broadcast all boundaries from master
+    MPI_Bcast(comm->xsplit, comm->procgrid[0]+1, MPI_DOUBLE, 0, world);
+    MPI_Bcast(comm->ysplit, comm->procgrid[1]+1, MPI_DOUBLE, 0, world);
+    MPI_Bcast(comm->zsplit, comm->procgrid[2]+1, MPI_DOUBLE, 0, world);
+
+  }
+}
+
+/**
+ *  Calculate imbalance based on the current scalar work.
+ *  @note updates imbalance
+ */
+
+void FixBalanceAll::calc_imbalance()
+{
+  double max, avg;
+  MPI_Allreduce(&work, &avg, 1, MPI_DOUBLE, MPI_SUM, world);
+  avg /= comm->nprocs;
+  MPI_Allreduce(&work, &max, 1, MPI_DOUBLE, MPI_MAX, world);
+
+  maxloadperproc = max;
+
+  if ((max < 0 || avg < 0 || max < avg) && comm->me == 0) error->warning(FLERR, "cannot calculate imbalance with max={} avg={}", max, avg);
+
+  if (max == 0) {
+    imbalance = -1;
+  } else {
+    imbalance = max / avg;
+  }
+}
+
+/**
+ * invoke init() for each Imbalance class
+ * flag = 0 for call from Balance, 1 for call from FixBalance
+ */
+
+void FixBalanceAll::init_imbalance(int flag = 1)
+{
+  if (!wtflag) return;
+  for (int n = 0; n < nimbalance; n++) imbalances[n]->init(flag);
+}
+
+/**
+ *  allocate per-particle weight storage for histogram via FixStoreAtom
+ *  fix could already be allocated if fix balance is re-specified
+ */
+
+void FixBalanceAll::weight_storage()
+{
+  std::string cmd;
+  cmd = id;
+  cmd += "HISTOGRAM_WEIGHTS";
+  fixstore = dynamic_cast<FixStoreAtom *>(modify->get_fix_by_id(cmd));
+  if (!fixstore) fixstore = dynamic_cast<FixStoreAtom *>(modify->add_fix(cmd + " all STORE/ATOM 1 0 0 0"));
+
+  // do not carry weights with atoms during normal atom migration
+  fixstore->disable = 1;
+}
+
+/**
+  *  set weight for each particle
+  */
+
+void FixBalanceAll::set_weights()
+{
+  if (!wtflag) return;
+  weight = fixstore->vstore;
+
+  int nlocal = atom->nlocal;
+  for (int i = 0; i < nlocal; i++) weight[i] = 1.0;
+  for (int n = 0; n < nimbalance; n++) imbalances[n]->compute(weight);
+
+  // weights need to migrate with atoms
+  fixstore->disable = 0;
+}
+
+/**
+  *  prevent further migration of weights
+  */
+
+void FixBalanceAll::unset_weights()
+{
+  if (!wtflag) return;
+
+  // weights should not migrate with atoms
+  fixstore->disable = 1;
+}
+
+/**
+ *  Calculate histogram for setWork of histogram balancing.
+ *  @note updates n_bins
+ *  @param[in] dimension in which the histogram is calculated
+ *  @return histogram for setWork
+ */
+
+std::vector<double> FixBalanceAll::calc_histogram(int dimension)
+{
+  // calculate the histogram width in a way that lower and upper box boundary match with a bin boundary
+  int n_bins_global = std::ceil(domain->prd[dimension] / bw);
+  const double bin_width = domain->prd[dimension] / n_bins_global;
+
+  double lb = std::ceil(my_vertices[0][dimension] / bin_width) * bin_width;
+  double ub = std::ceil(my_vertices[1][dimension] / bin_width) * bin_width;
+
+  double overlap = 0; // bin -1 which is send to lower neighbour
+
+  n_bins.at(dimension) = (int) (std::round((ub -lb) / bin_width) + 1e-4);
+
+  std::vector<double> work_vec(n_bins.at(dimension), 0.0);
+
+  // compute histogram of work load
+  double ** x = atom->x;
+
+  // the work per atom is constant
+  // -> set work before iterating over atoms
+  double work_atom = 1.0;
+  double *weight = nullptr;
+  if (wtflag) weight = fixstore->vstore;
+
+  for (int i = 0; i < atom->nlocal; i++) {
+
+    // calculate bin of atom
+    const int idx = std::floor(((x[i][dimension] - domain->boxlo[dimension] - lb) / bin_width));
+
+    // use individual weight or previously defined work
+    if (wtflag) work_atom = weight[i];
+
+    // update corresponding bin
+    if (idx >= 0 && idx < n_bins.at(dimension)) {
+      work_vec.at(idx) += work_atom;
+    } else if (idx == -1) {
+      overlap += work_atom;
+    } else if (idx == n_bins.at(dimension) && fabs(x[i][dimension] - my_vertices[1][dimension]) < 1e-6) {
+      // floating point issue, just use the last bin
+      work_vec.at(n_bins.at(dimension) - 1) += work_atom;
+    } else {
+      error->one(FLERR, "balance/all: unexpected histogram bin {} for histogram of size {} x {} lb {} bin_width {} boxlo {} myvert_lo {} myvert_hi {}", idx, n_bins.at(dimension), x[i][dimension], lb, bin_width, domain->boxlo[dimension], my_vertices[0][dimension], my_vertices[1][dimension]);
+    }
+  }
+
+  // calculate ranks of neighbours
+  //myloc_vec.assign(comm->myloc, comm->myloc+3);
+  int rank_left = MPI_PROC_NULL;
+  int rank_right = MPI_PROC_NULL;
+  int loc_ngh[3];
+  loc_ngh[0] = myloc_vec[0];
+  loc_ngh[1] = myloc_vec[1];
+  loc_ngh[2] = myloc_vec[2];
+  // left neighbour
+  loc_ngh[dimension] -= 1;
+  if (loc_ngh[dimension] >= 0)
+    rank_left = comm->grid2proc[loc_ngh[0]][loc_ngh[1]][loc_ngh[2]];
+  // right neighbour
+  loc_ngh[dimension] += 2;
+  if (loc_ngh[dimension] < procgrid_vec[dimension])
+    rank_right = comm->grid2proc[loc_ngh[0]][loc_ngh[1]][loc_ngh[2]];
+
+  // exchange overlapping workload (histograms might overlap
+  // over the domain boundaries
+
+  MPI_Request sreq, rreq;
+  MPI_Status ssta, rsta;
+
+  double recv_work = 0;
+
+  MPI_Isend(&overlap, 1, MPI_DOUBLE, rank_left, 0, world, &sreq);
+  MPI_Irecv(&recv_work, 1, MPI_DOUBLE, rank_right, 0, world, &rreq);
+  MPI_Wait(&rreq, &rsta);
+  MPI_Wait(&sreq, &ssta);
+
+  work_vec.at(n_bins.at(dimension) - 1) += recv_work;
+
+  return work_vec;
+}
+
+/**
+ *  For lammps output only.
+ *  @param[in] i index of output vector
+ *  @return requested value
+ */
+
+double FixBalanceAll::compute_vector(int i)
+{
+  // TODO: remove communication and lb timing (doing more than required)
+  if (/*remove*/reduce_outvec_flag/*elsewhere*/) {
+    double reducebuffer_s, reducebuffer_r;
+    reducebuffer_s = /*remove!*/timer_lb/*elsewhere*/;
+
+    // calc min
+    MPI_Allreduce(&reducebuffer_s, &reducebuffer_r, 1, MPI_DOUBLE, MPI_MIN, world);
+    outvec_timer[0] = reducebuffer_r;
+
+    // calc avg
+    MPI_Allreduce(&reducebuffer_s, &reducebuffer_r, 1, MPI_DOUBLE, MPI_SUM, world);
+    outvec_timer[1] = reducebuffer_r / comm->nprocs;
+
+    // calc max
+    MPI_Allreduce(&reducebuffer_s, &reducebuffer_r, 1, MPI_DOUBLE, MPI_MAX, world);
+    outvec_timer[2] = reducebuffer_r;
+
+    reduce_outvec_flag = false;
+  }
+
+  if (i == 0) return maxloadperproc;
+  if (i == 1) return imbalance;
+  if (i <= 4) return outvec_timer[i-3];
+  return -1;
+}
+
+/**
+ *  For lammps stats only.
+ *  @return # of bytes of allocated memory
+ */
+
+double FixBalanceAll::memory_usage()
+{
+  double bytes = irregular->memory_usage();
+  return bytes;
+}
+
diff -ruN a/src/ALLPKG/fix_balance_all.h b/src/ALLPKG/fix_balance_all.h
--- a/src/ALLPKG/fix_balance_all.h	1970-01-01 01:00:00.000000000 +0100
+++ b/src/ALLPKG/fix_balance_all.h	2025-11-05 16:36:36.437836000 +0100
@@ -0,0 +1,119 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+// clang-format off
+FixStyle(balance/all,FixBalanceAll);
+// clang-format on
+#else
+
+#ifndef LMP_FIX_BALANCE_ALL_H
+#define LMP_FIX_BALANCE_ALL_H
+
+#include "fix.h"
+#include "ALL.hpp"
+#include "pointers.h"
+#include <mpi.h>
+
+namespace LAMMPS_NS {
+
+class FixBalanceAll : public Fix {
+ public:
+  FixBalanceAll(class LAMMPS *, int, char **);
+  ~FixBalanceAll() override;
+  int setmask() override;
+  void post_constructor() override;
+  void init() override;
+  void pre_exchange() override;
+  double compute_vector(int) override;
+  double memory_usage() override;
+
+ private:
+
+  bigint lastbalance;           // last timestep balancing was attempted
+
+  double maxloadperproc;        // max load on any processor
+
+  // user set variables
+
+  int nevery;                   // call load balancer after nevery steps
+  int gridstyle;                // STAGGERED, TENSOR, UNKNOWN_GRID
+  int wtflag;                   // use per atom weights 1, otherwise 0
+  int varflag;                  // 1 if weight style var(iable) is used
+  double bw;                    // bin width for histogram
+  double local_threshold;       // imbalance threshold for tensor and staggered
+  double global_threshold;      // imbalance threshold for histogram
+  bool use_bw_threshold;        // bin width threshold set
+  bool use_local_lb;            // all_local (staggered or tensor) required
+  bool use_global_lb;           // all_global (histogram) required
+  bool verbose;                 // write stats to log
+
+  // calculated variables
+
+  double work;                  // load of this rank
+  double imbalance;             // max work / avg work
+  double timer_lb;              // duration of load balancing step in seconds
+  MPI_Comm x_masters;           // for tensor to gather xsplit
+  MPI_Comm y_masters;           // for tensor to gather ysplit
+  MPI_Comm z_masters;           // for tensor to gather zsplit
+  bool reduce_outvec_flag;      // recaluclate out vector?
+  double outvec_timer[3]; // TODO: remove
+
+  // ALL objects
+
+  ALL::ALL<double, double> *all_local;   // staggered or tensor
+  ALL::ALL<double, double> *all_global;  // histogram
+  ALL::ALL<double, double> *all_last;    // pointer to last used object or nullptr
+
+  // ALL input
+
+  std::vector<int> n_bins;                      // number of bin of histogram
+  std::vector<int> myloc_vec;                   // position in staggered/tensor gird per dimension
+  std::vector<int> procgrid_vec;                // size of staggered/tensor grid per dimension
+  std::vector<double> minimum_domain_size;      // in box units [0, domain->prd]
+  std::vector<ALL::Point<double>> my_vertices;  // in box units [0, domain->prd]
+
+  // class pointers
+
+  class FixStoreAtom *fixstore;     // per-atom weights for histogram stored in FixStore
+  class Irregular *irregular;       // for atom migration after boudary update
+
+  int nimbalance;                   // number of user-specified weight styles
+  class Imbalance **imbalances;     // list of Imb classes, one per weight style
+  double *weight;                   // ptr to FixStore weight vector
+
+  // functions
+
+  std::vector<ALL::Point<double>> get_comm_vertices();
+  std::vector<double> calc_histogram(int);
+  std::vector<double> get_sys_size_from_domain();
+  double get_work();
+
+  void set_comm_vertices(std::vector<ALL::Point<double>>);
+
+  void balance();
+  void balance_local();
+  void balance_global();
+  void init_imbalance(int);
+  void calc_imbalance();
+  void set_weights();
+  void unset_weights();
+
+  void weight_storage();
+
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN a/src/ALLPKG/Install.sh b/src/ALLPKG/Install.sh
--- a/src/ALLPKG/Install.sh	1970-01-01 01:00:00.000000000 +0100
+++ b/src/ALLPKG/Install.sh	2025-11-05 16:36:36.438180663 +0100
@@ -0,0 +1,64 @@
+# Install/unInstall package files in LAMMPS
+# mode = 0/1/2 for uninstall/install/update
+
+mode=$1
+
+# enforce using portable C locale
+LC_ALL=C
+export LC_ALL
+
+# arg1 = file, arg2 = file it depends on
+
+action () {
+  if (test $mode = 0) then
+    rm -f ../$1
+  elif (! cmp -s $1 ../$1) then
+    if (test -z "$2" || test -e ../$2) then
+      cp $1 ..
+      if (test $mode = 2) then
+        echo "  updating src/$1"
+      fi
+    fi
+  elif (test -n "$2") then
+    if (test ! -e ../$2) then
+      rm -f ../$1
+    fi
+  fi
+}
+
+# list of package files with otional dependencies
+
+action fix_balance_all.h
+action fix_balance_all.cpp
+
+# edit 2 Makefile.package files to include/exclude package info
+
+if (test $1 = 1) then
+
+  if (test -e ../Makefile.package) then
+    sed -i -e 's/[^ \t]*allpkg[^ \t]* //' ../Makefile.package
+    sed -i -e 's|^PKG_SYSINC =[ \t]*|&$(allpkg_SYSINC) |' ../Makefile.package
+    sed -i -e 's|^PKG_SYSLIB =[ \t]*|&$(allpkg_SYSLIB) |' ../Makefile.package
+    sed -i -e 's|^PKG_SYSPATH =[ \t]*|&$(allpkg_SYSPATH) |' ../Makefile.package
+  fi
+
+  if (test -e ../Makefile.package.settings) then
+    sed -i -e '/^include.*allpkg.*$/d' ../Makefile.package.settings
+    # multiline form needed for BSD sed on Macs
+    sed -i -e '4 i \
+include ..\/..\/lib\/allpkg\/Makefile.lammps
+' ../Makefile.package.settings
+  fi
+
+elif (test $1 = 0) then
+
+  if (test -e ../Makefile.package) then
+    sed -i -e 's/[^ \t]*allpkg[^ \t]* //' ../Makefile.package
+  fi
+
+  if (test -e ../Makefile.package.settings) then
+    sed -i -e '/^[ \t]*include.*allpkg.*$/d' ../Makefile.package.settings
+  fi
+
+fi
+
diff -ruN a/src/comm.cpp b/src/comm.cpp
--- a/src/comm.cpp	2025-11-05 15:55:23.892438000 +0100
+++ b/src/comm.cpp	2025-11-05 16:36:36.439403000 +0100
@@ -78,8 +78,11 @@
   bufextra_max = bufextra;
 
   grid2proc = nullptr;
+  staggered_grid2proc = nullptr;
+  staggered_proc2grid = nullptr;
   xsplit = ysplit = zsplit = nullptr;
   rcbnew = 0;
+  staggerednew = 0;
   multi_reduce = 0;
 
   // use of OpenMP threads
@@ -109,6 +112,7 @@
   if (me == 0)
     utils::logmesg(lmp,"  using {} OpenMP thread(s) per MPI task\n",nthreads);
 #endif
+  mysplit[0][0] = mysplit[0][1] = mysplit[1][0] = mysplit[1][1] = mysplit[2][0] = mysplit[2][1] = 0;
 
 }
 
@@ -117,6 +121,8 @@
 Comm::~Comm()
 {
   memory->destroy(grid2proc);
+  memory->destroy(staggered_grid2proc);
+  memory->destroy(staggered_proc2grid);
   memory->destroy(xsplit);
   memory->destroy(ysplit);
   memory->destroy(zsplit);
diff -ruN a/src/comm.h b/src/comm.h
--- a/src/comm.h	2025-11-05 15:55:26.677020000 +0100
+++ b/src/comm.h	2025-11-05 16:36:36.440611000 +0100
@@ -20,14 +20,16 @@
 
 class Comm : protected Pointers {
  public:
-  enum { BRICK, TILED };
+  enum { BRICK, TILED, STAGGERED };
   int style;    // BRICK = 6-way stencil communication
                 // TILED = irregular tiling communication
+                // STAGGERED = staggered communication
 
-  enum { LAYOUT_UNIFORM, LAYOUT_NONUNIFORM, LAYOUT_TILED };
+  enum { LAYOUT_UNIFORM, LAYOUT_NONUNIFORM, LAYOUT_TILED, LAYOUT_STAGGERED };
   int layout;    // LAYOUT_UNIFORM = equal-sized bricks
                  // LAYOUT_NONUNIFORM = logical bricks, but diff sizes via LB
                  // LAYOUT_TILED = general tiling, due to RCB LB
+                 // LAYOUT_STAGGERED = staggered mesh due to LB
   enum { SINGLE, MULTI, MULTIOLD };
   int mode;    // SINGLE = single cutoff
                // MULTI = multi-collection cutoff
@@ -65,6 +67,17 @@
   double rcbcutfrac;       // fractional RCB cut by this proc
   int rcbcutdim;           // dimension of RCB cut
 
+  // public settings specific to layout = STAGGERED
+
+  int *** staggered_grid2proc;      // which proc owns layer,row,cell in staggered grid
+  int ** staggered_proc2grid;       // which location (layer,row,cell) is owned by proc in staggered grid
+  int staggerednew;                 // 1 if just reset by rebalance, else 0
+  int staggered_procgrid[3];        // layers, rows, cells
+  int staggered_myloc[3];           // layers, rows, cells
+  int n_layers, n_rows, n_cells;    // number of layers/rows/cells
+  int staggered2spatial[3];         // layer/row/cell to x/y/z
+  int spatial2staggered[3];         // x/y/z to layer/row/cell
+
   // methods
 
   Comm(class LAMMPS *);
diff -ruN a/src/comm_staggered.cpp b/src/comm_staggered.cpp
--- a/src/comm_staggered.cpp	1970-01-01 01:00:00.000000000 +0100
+++ b/src/comm_staggered.cpp	2025-11-05 16:36:36.441120000 +0100
@@ -0,0 +1,1215 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "comm_staggered.h"
+
+#include "atom.h"
+#include "atom_vec.h"
+#include "bond.h"
+#include "compute.h"
+#include "domain.h"
+#include "dump.h"
+#include "error.h"
+#include "fix.h"
+#include "memory.h"
+#include "neighbor.h"
+#include "pair.h"
+
+#include <cmath>
+#include <cstring>
+
+using namespace LAMMPS_NS;
+
+static constexpr double BUFFACTOR = 1.5;
+static constexpr int BUFMIN = 1024;
+static constexpr double EPSILON = 1.0e-6;
+static constexpr int DELTA_PROCS = 16;
+
+
+/* ---------------------------------------------------------------------- */
+//IMPORTANT: we *MUST* pass "*oldcomm" to the Comm initializer here, as
+//           the code below *requires* that the (implicit) copy constructor
+//           for Comm is run and thus creating a shallow copy of "oldcomm".
+//           The call to Comm::copy_arrays() then converts the shallow copy
+//           into a deep copy of the class with the new layout.
+//           @todo search 'comm->layout' and adapt foreign functions for
+//                  LAYOUT_STAGGERED
+
+CommStaggered::CommStaggered(LAMMPS *lmp, Comm *oldcomm, char *arg) : CommTiled(lmp, oldcomm)
+{
+  if (oldcomm->layout == Comm::LAYOUT_TILED)
+    error->all(FLERR,"Cannot change to comm_style staggered from tiled layout");
+  if (oldcomm->layout == Comm::LAYOUT_STAGGERED)
+    error->all(FLERR,"Conversion from staggered layout to staggered layout is not allowed");
+
+  style = Comm::STAGGERED;
+  if (strlen(arg) != 3) error->all(FLERR, "expected 3 chars instead of {}", strlen(arg));
+  for (int i = 0; i < 3; i++) {
+    if (arg[i] == 'x') staggered2spatial[i] = 0;
+    else if (arg[i] == 'y') staggered2spatial[i] = 1;
+    else if (arg[i] == 'z') staggered2spatial[i] = 2;
+    else error->all(FLERR, "expected x,y or z instead of {} in staggered config", arg[i]);
+    spatial2staggered[staggered2spatial[i]] = i;
+  }
+
+  init_buffers_staggered();
+}
+
+/**
+  * Free allocated memory specific to staggered.
+  */
+
+CommStaggered::~CommStaggered()
+{
+  if (layer_splits) memory->destroy(layer_splits);
+  if (row_splits) memory->destroy(row_splits);
+  if (cell_splits) memory->destroy(cell_splits);
+}
+
+/**
+  * initialise comm buffers and other data structs local to CommStaggered but not to CommTiled
+  */
+
+void CommStaggered::init_buffers_staggered()
+{
+  // allocate memory and store constant quantities
+  for (int i = 0; i < 3; i++) {
+    staggered_procgrid[spatial2staggered[i]] = procgrid[i];
+    staggered_myloc[spatial2staggered[i]] = myloc[i];
+  }
+  n_layers = staggered_procgrid[0];
+  n_rows = staggered_procgrid[1];
+  n_cells = staggered_procgrid[2];
+
+  memory->create(layer_splits, n_layers+1, "comm:layer_splits");
+  memory->create(row_splits, n_layers, n_rows+1, "comm:row_splits");
+  memory->create(cell_splits, n_layers, n_rows, n_cells+1, "comm:cell_splits");
+  memory->create(staggered_grid2proc, n_layers, n_rows, n_cells, "comm:staggered_grid2proc");
+  memory->create(staggered_proc2grid, nprocs, 3, "comm:staggered_proc2grid");
+
+  int tmploc[3];
+  for (tmploc[0] = 0; tmploc[0] < n_layers; tmploc[0]++) {
+    for (tmploc[1] = 0; tmploc[1] < n_rows; tmploc[1]++) {
+      for (tmploc[2] = 0; tmploc[2] < n_cells; tmploc[2]++) {
+        staggered_grid2proc[tmploc[0]][tmploc[1]][tmploc[2]] = grid2proc[tmploc[spatial2staggered[0]]]
+                                                   [tmploc[spatial2staggered[1]]]
+                                                   [tmploc[spatial2staggered[2]]];
+      }
+    }
+  }
+  int gatherbuffer[nprocs*3];
+  gatherbuffer[me*3+0] = staggered_myloc[0];
+  gatherbuffer[me*3+1] = staggered_myloc[1];
+  gatherbuffer[me*3+2] = staggered_myloc[2];
+  MPI_Allgather(MPI_IN_PLACE,3,MPI_INT,gatherbuffer,3,MPI_INT,world);
+  for (int i=0; i < nprocs; i++) {
+    staggered_proc2grid[i][0] = gatherbuffer[i*3+0];
+    staggered_proc2grid[i][1] = gatherbuffer[i*3+1];
+    staggered_proc2grid[i][2] = gatherbuffer[i*3+2];
+  }
+}
+
+/**
+  * setup spatial-decomposition communication patterns
+  * function of neighbor cutoff(s) & cutghostuser & current box size and tiling
+  */
+
+void CommStaggered::setup()
+{
+  int i,j,n;
+
+  // domain properties used in setup method and methods it calls
+
+  dimension = domain->dimension;
+  int *periodicity = domain->periodicity;
+  int ntypes = atom->ntypes;
+
+  if (triclinic == 0) {
+    prd = domain->prd;
+    boxlo = domain->boxlo;
+    boxhi = domain->boxhi;
+    sublo = domain->sublo;
+    subhi = domain->subhi;
+  } else {
+    prd = domain->prd_lamda;
+    boxlo = domain->boxlo_lamda;
+    boxhi = domain->boxhi_lamda;
+    sublo = domain->sublo_lamda;
+    subhi = domain->subhi_lamda;
+  }
+
+  // set function pointers
+
+  if (layout == Comm::LAYOUT_STAGGERED) {
+    box_drop = &CommStaggered::box_drop_staggered;
+    box_other = &CommStaggered::box_other_staggered;
+    box_touch = &CommStaggered::box_touch_staggered;
+    point_drop = &CommStaggered::point_drop_staggered;
+  } else {
+    // set brick for this class
+    box_drop = &CommStaggered::box_drop_brick;
+    box_other = &CommStaggered::box_other_brick;
+    box_touch = &CommStaggered::box_touch_brick;
+    point_drop = &CommStaggered::point_drop_brick;
+    // set brick for parent class
+    CommTiled::box_drop = &CommStaggered::box_drop_brick;
+    CommTiled::box_other = &CommStaggered::box_other_brick;
+    CommTiled::box_touch = &CommStaggered::box_touch_brick;
+    CommTiled::point_drop = &CommStaggered::point_drop_brick;
+  }
+
+  // if RCB decomp exists and just changed, gather needed global RCB info
+
+  if (layout == Comm::LAYOUT_STAGGERED) coord2proc_setup();
+
+  // set cutoff for comm forward and comm reverse
+  // check that cutoff < any periodic box length
+
+  if (mode == Comm::MULTI) {
+    double **cutcollectionsq = neighbor->cutcollectionsq;
+
+    // build collection array for atom exchange
+    neighbor->build_collection(0);
+
+    // If using multi/reduce, communicate particles a distance equal
+    // to the max cutoff with equally sized or smaller collections
+    // If not, communicate the maximum cutoff of the entire collection
+    for (i = 0; i < ncollections; i++) {
+      if (cutusermulti) {
+        cutghostmulti[i][0] = cutusermulti[i];
+        cutghostmulti[i][1] = cutusermulti[i];
+        cutghostmulti[i][2] = cutusermulti[i];
+      } else {
+        cutghostmulti[i][0] = 0.0;
+        cutghostmulti[i][1] = 0.0;
+        cutghostmulti[i][2] = 0.0;
+      }
+
+      for (j = 0; j < ncollections; j++){
+        if (multi_reduce && (cutcollectionsq[j][j] > cutcollectionsq[i][i])) continue;
+        cutghostmulti[i][0] = MAX(cutghostmulti[i][0],sqrt(cutcollectionsq[i][j]));
+        cutghostmulti[i][1] = MAX(cutghostmulti[i][1],sqrt(cutcollectionsq[i][j]));
+        cutghostmulti[i][2] = MAX(cutghostmulti[i][2],sqrt(cutcollectionsq[i][j]));
+      }
+    }
+  }
+
+  if (mode == Comm::MULTIOLD) {
+    double *cuttype = neighbor->cuttype;
+    for (i = 1; i <= ntypes; i++) {
+      double tmp = 0.0;
+      if (cutusermultiold) tmp = cutusermultiold[i];
+      cutghostmultiold[i][0] = MAX(tmp,cuttype[i]);
+      cutghostmultiold[i][1] = MAX(tmp,cuttype[i]);
+      cutghostmultiold[i][2] = MAX(tmp,cuttype[i]);
+    }
+  }
+
+  double cut = get_comm_cutoff();
+  if ((cut == 0.0) && (me == 0))
+    error->warning(FLERR,"Communication cutoff is 0.0. No ghost atoms "
+                   "will be generated. Atoms may get lost.");
+
+  if (triclinic == 0) cutghost[0] = cutghost[1] = cutghost[2] = cut;
+  else {
+    double *h_inv = domain->h_inv;
+    double length0,length1,length2;
+    length0 = sqrt(h_inv[0]*h_inv[0] + h_inv[5]*h_inv[5] + h_inv[4]*h_inv[4]);
+    cutghost[0] = cut * length0;
+    length1 = sqrt(h_inv[1]*h_inv[1] + h_inv[3]*h_inv[3]);
+    cutghost[1] = cut * length1;
+    length2 = h_inv[2];
+    cutghost[2] = cut * length2;
+    if (mode == Comm::MULTI) {
+      for (i = 0; i < ncollections; i++) {
+        cutghostmulti[i][0] *= length0;
+        cutghostmulti[i][1] *= length1;
+        cutghostmulti[i][2] *= length2;
+      }
+    }
+
+    if (mode == Comm::MULTIOLD) {
+      for (i = 1; i <= ntypes; i++) {
+        cutghostmultiold[i][0] *= length0;
+        cutghostmultiold[i][1] *= length1;
+        cutghostmultiold[i][2] *= length2;
+      }
+    }
+  }
+
+  if ((periodicity[0] && cutghost[0] > prd[0]) ||
+      (periodicity[1] && cutghost[1] > prd[1]) ||
+      (dimension == 3 && periodicity[2] && cutghost[2] > prd[2]))
+    error->all(FLERR,"Communication cutoff for comm_style tiled "
+               "cannot exceed periodic box length");
+
+  // if cut = 0.0, set to epsilon to induce nearest neighbor comm
+  // this is b/c sendproc is used below to infer touching exchange procs
+  // exchange procs will be empty (leading to lost atoms) if sendproc = 0
+  // will reset sendproc/etc to 0 after exchange is setup, down below
+
+  int cutzero = 0;
+  if (cut == 0.0) {
+    cutzero = 1;
+    cut = MIN(prd[0],prd[1]);
+    if (dimension == 3) cut = MIN(cut,prd[2]);
+    cut *= EPSILON*EPSILON;
+    cutghost[0] = cutghost[1] = cutghost[2] = cut;
+  }
+
+  // setup forward/reverse communication
+  // loop over 6 swap directions
+  // determine which procs I will send to and receive from in each swap
+  // done by intersecting ghost box with all proc sub-boxes it overlaps
+  // sets nsendproc, nrecvproc, sendproc, recvproc
+  // sets sendother, recvother, sendself, pbc_flag, pbc, sendbox
+  // resets nprocmax
+
+  int noverlap1,indexme;
+  double lo1[3],hi1[3],lo2[3],hi2[3];
+  int one,two;
+
+  int iswap = 0;
+  for (int idim = 0; idim < dimension; idim++) {
+    for (int idir = 0; idir < 2; idir++) {
+
+      // one = first ghost box in same periodic image
+      // two = second ghost box wrapped across periodic boundary
+      // either may not exist
+
+      one = 1;
+      lo1[0] = sublo[0]; lo1[1] = sublo[1]; lo1[2] = sublo[2];
+      hi1[0] = subhi[0]; hi1[1] = subhi[1]; hi1[2] = subhi[2];
+      if (idir == 0) {
+        lo1[idim] = sublo[idim] - cutghost[idim];
+        hi1[idim] = sublo[idim];
+      } else {
+        lo1[idim] = subhi[idim];
+        hi1[idim] = subhi[idim] + cutghost[idim];
+      }
+
+      two = 0;
+      if (idir == 0 && periodicity[idim] && lo1[idim] < boxlo[idim]) two = 1;
+      if (idir == 1 && periodicity[idim] && hi1[idim] > boxhi[idim]) two = 1;
+
+      if (two) {
+        lo2[0] = sublo[0]; lo2[1] = sublo[1]; lo2[2] = sublo[2];
+        hi2[0] = subhi[0]; hi2[1] = subhi[1]; hi2[2] = subhi[2];
+        if (idir == 0) {
+          lo2[idim] = lo1[idim] + prd[idim];
+          hi2[idim] = boxhi[idim];
+          if (sublo[idim] == boxlo[idim]) one = 0;
+        } else {
+          lo2[idim] = boxlo[idim];
+          hi2[idim] = hi1[idim] - prd[idim];
+          if (subhi[idim] == boxhi[idim]) one = 0;
+        }
+      }
+
+      if (one) {
+        if (idir == 0) lo1[idim] = MAX(lo1[idim],boxlo[idim]);
+        else hi1[idim] = MIN(hi1[idim],boxhi[idim]);
+        if (lo1[idim] == hi1[idim]) one = 0;
+      }
+      if (one && idir == 0 && layout == Comm::LAYOUT_STAGGERED && staggered_myloc[spatial2staggered[idim]] == 0) error->one(FLERR, "one set for communication in direction 0, but there is no processor");
+      if (one && idir == 1 && layout == Comm::LAYOUT_STAGGERED && staggered_myloc[spatial2staggered[idim]] == staggered_procgrid[spatial2staggered[idim]] -1) error->one(FLERR, "one set for communication in direction 1, but there is no processor");
+
+      // noverlap = # of overlaps of box1/2 with procs via box_drop()
+      // overlap = list of overlapping procs
+      // if overlap with self, indexme = index of me in list
+
+      indexme = -1;
+      noverlap = 0;
+
+      if (one) (this->*box_drop)(idim,lo1,hi1,indexme);
+      noverlap1 = noverlap;
+      if (two) (this->*box_drop)(idim,lo2,hi2,indexme);
+
+      // if self is in overlap list, move it to end of list
+
+      if (indexme >= 0) {
+        int tmp = overlap[noverlap-1];
+        overlap[noverlap-1] = overlap[indexme];
+        overlap[indexme] = tmp;
+      }
+
+      // reallocate 2nd dimensions of all send/recv arrays, based on noverlap
+      // # of sends of this swap = # of recvs of iswap +/- 1
+
+      if (noverlap > nprocmax[iswap]) {
+        int oldmax = nprocmax[iswap];
+        while (nprocmax[iswap] < noverlap) nprocmax[iswap] += DELTA_PROCS;
+        grow_swap_send(iswap,nprocmax[iswap],oldmax);
+        if (idir == 0) grow_swap_recv(iswap+1,nprocmax[iswap]);
+        else grow_swap_recv(iswap-1,nprocmax[iswap]);
+      }
+
+      // overlap how has list of noverlap procs
+      // includes PBC effects
+
+      if (noverlap && overlap[noverlap-1] == me) sendself[iswap] = 1;
+      else sendself[iswap] = 0;
+      if (noverlap && noverlap-sendself[iswap]) sendother[iswap] = 1;
+      else sendother[iswap] = 0;
+
+      nsendproc[iswap] = noverlap;
+      for (i = 0; i < noverlap; i++) sendproc[iswap][i] = overlap[i];
+
+      if (idir == 0) {
+        recvother[iswap+1] = sendother[iswap];
+        nrecvproc[iswap+1] = noverlap;
+        for (i = 0; i < noverlap; i++) recvproc[iswap+1][i] = overlap[i];
+      } else {
+        recvother[iswap-1] = sendother[iswap];
+        nrecvproc[iswap-1] = noverlap;
+        for (i = 0; i < noverlap; i++) recvproc[iswap-1][i] = overlap[i];
+      }
+
+      // compute sendbox for each of my sends
+      // obox = intersection of ghostbox with other proc's sub-domain
+      // sbox = what I need to send to other proc
+      //      = sublo to MIN(sublo+cut,subhi) in idim, for idir = 0
+      //      = MIN(subhi-cut,sublo) to subhi in idim, for idir = 1
+      //      = obox in other 2 dims
+      // if sbox touches other proc's sub-box boundaries in lower dims,
+      //   extend sbox in those lower dims to include ghost atoms
+      // single mode and multi mode
+
+      double oboxlo[3],oboxhi[3],sbox[6],sbox_multi[6],sbox_multiold[6];
+
+      if (mode == Comm::SINGLE) {
+        for (i = 0; i < noverlap; i++) {
+          pbc_flag[iswap][i] = 0;
+          pbc[iswap][i][0] = pbc[iswap][i][1] = pbc[iswap][i][2] =
+            pbc[iswap][i][3] = pbc[iswap][i][4] = pbc[iswap][i][5] = 0;
+
+          (this->*box_other)(idim,idir,overlap[i],oboxlo,oboxhi);
+
+          if (i < noverlap1) {
+            sbox[0] = MAX(oboxlo[0],lo1[0]);
+            sbox[1] = MAX(oboxlo[1],lo1[1]);
+            sbox[2] = MAX(oboxlo[2],lo1[2]);
+            sbox[3] = MIN(oboxhi[0],hi1[0]);
+            sbox[4] = MIN(oboxhi[1],hi1[1]);
+            sbox[5] = MIN(oboxhi[2],hi1[2]);
+          } else {
+            pbc_flag[iswap][i] = 1;
+            if (idir == 0) pbc[iswap][i][idim] = 1;
+            else pbc[iswap][i][idim] = -1;
+            if (triclinic) {
+              if (idim == 1) pbc[iswap][i][5] = pbc[iswap][i][idim];
+              if (idim == 2) pbc[iswap][i][4] = pbc[iswap][i][3] = pbc[iswap][i][idim];
+            }
+            sbox[0] = MAX(oboxlo[0],lo2[0]);
+            sbox[1] = MAX(oboxlo[1],lo2[1]);
+            sbox[2] = MAX(oboxlo[2],lo2[2]);
+            sbox[3] = MIN(oboxhi[0],hi2[0]);
+            sbox[4] = MIN(oboxhi[1],hi2[1]);
+            sbox[5] = MIN(oboxhi[2],hi2[2]);
+          }
+
+          if (idir == 0) {
+            sbox[idim] = sublo[idim];
+            if (i < noverlap1)
+              sbox[3+idim] = MIN(sbox[3+idim]+cutghost[idim],subhi[idim]);
+            else
+              sbox[3+idim] = MIN(sbox[3+idim]-prd[idim]+cutghost[idim],subhi[idim]);
+          } else {
+            if (i < noverlap1) sbox[idim] = MAX(sbox[idim]-cutghost[idim],sublo[idim]);
+            else sbox[idim] = MAX(sbox[idim]+prd[idim]-cutghost[idim],sublo[idim]);
+            sbox[3+idim] = subhi[idim];
+          }
+
+          if (idim >= 1) {
+            if (sbox[0] == oboxlo[0]) sbox[0] -= cutghost[0];
+            if (sbox[3] == oboxhi[0]) sbox[3] += cutghost[0];
+          }
+          if (idim == 2) {
+            if (sbox[1] == oboxlo[1]) sbox[1] -= cutghost[1];
+            if (sbox[4] == oboxhi[1]) sbox[4] += cutghost[1];
+          }
+
+          memcpy(sendbox[iswap][i],sbox,6*sizeof(double));
+        }
+      }
+
+      if (mode == Comm::MULTI) {
+        for (i = 0; i < noverlap; i++) {
+          pbc_flag[iswap][i] = 0;
+          pbc[iswap][i][0] = pbc[iswap][i][1] = pbc[iswap][i][2] =
+            pbc[iswap][i][3] = pbc[iswap][i][4] = pbc[iswap][i][5] = 0;
+
+          (this->*box_other)(idim,idir,overlap[i],oboxlo,oboxhi);
+
+          if (i < noverlap1) {
+            sbox[0] = MAX(oboxlo[0],lo1[0]);
+            sbox[1] = MAX(oboxlo[1],lo1[1]);
+            sbox[2] = MAX(oboxlo[2],lo1[2]);
+            sbox[3] = MIN(oboxhi[0],hi1[0]);
+            sbox[4] = MIN(oboxhi[1],hi1[1]);
+            sbox[5] = MIN(oboxhi[2],hi1[2]);
+          } else {
+            pbc_flag[iswap][i] = 1;
+            if (idir == 0) pbc[iswap][i][idim] = 1;
+            else pbc[iswap][i][idim] = -1;
+            if (triclinic) {
+              if (idim == 1) pbc[iswap][i][5] = pbc[iswap][i][idim];
+              if (idim == 2) pbc[iswap][i][4] = pbc[iswap][i][3] = pbc[iswap][i][idim];
+            }
+            sbox[0] = MAX(oboxlo[0],lo2[0]);
+            sbox[1] = MAX(oboxlo[1],lo2[1]);
+            sbox[2] = MAX(oboxlo[2],lo2[2]);
+            sbox[3] = MIN(oboxhi[0],hi2[0]);
+            sbox[4] = MIN(oboxhi[1],hi2[1]);
+            sbox[5] = MIN(oboxhi[2],hi2[2]);
+          }
+
+          for (int icollection = 0; icollection < ncollections; icollection++) {
+            sbox_multi[0] = sbox[0];
+            sbox_multi[1] = sbox[1];
+            sbox_multi[2] = sbox[2];
+            sbox_multi[3] = sbox[3];
+            sbox_multi[4] = sbox[4];
+            sbox_multi[5] = sbox[5];
+            if (idir == 0) {
+              sbox_multi[idim] = sublo[idim];
+              if (i < noverlap1)
+                sbox_multi[3+idim] =
+                  MIN(sbox_multi[3+idim]+cutghostmulti[icollection][idim],subhi[idim]);
+              else
+                sbox_multi[3+idim] =
+                  MIN(sbox_multi[3+idim]-prd[idim]+cutghostmulti[icollection][idim],subhi[idim]);
+            } else {
+              if (i < noverlap1)
+                sbox_multi[idim] =
+                  MAX(sbox_multi[idim]-cutghostmulti[icollection][idim],sublo[idim]);
+              else
+                sbox_multi[idim] =
+                  MAX(sbox_multi[idim]+prd[idim]-cutghostmulti[icollection][idim],sublo[idim]);
+              sbox_multi[3+idim] = subhi[idim];
+            }
+
+            if (idim >= 1) {
+              if (sbox_multi[0] == oboxlo[0])
+                sbox_multi[0] -= cutghostmulti[icollection][idim];
+              if (sbox_multi[3] == oboxhi[0])
+                sbox_multi[3] += cutghostmulti[icollection][idim];
+            }
+            if (idim == 2) {
+              if (sbox_multi[1] == oboxlo[1])
+                sbox_multi[1] -= cutghostmulti[icollection][idim];
+              if (sbox_multi[4] == oboxhi[1])
+                sbox_multi[4] += cutghostmulti[icollection][idim];
+            }
+
+            memcpy(sendbox_multi[iswap][i][icollection],sbox_multi,6*sizeof(double));
+          }
+        }
+      }
+
+      if (mode == Comm::MULTIOLD) {
+        for (i = 0; i < noverlap; i++) {
+          pbc_flag[iswap][i] = 0;
+          pbc[iswap][i][0] = pbc[iswap][i][1] = pbc[iswap][i][2] =
+            pbc[iswap][i][3] = pbc[iswap][i][4] = pbc[iswap][i][5] = 0;
+
+          (this->*box_other)(idim,idir,overlap[i],oboxlo,oboxhi);
+
+          if (i < noverlap1) {
+            sbox[0] = MAX(oboxlo[0],lo1[0]);
+            sbox[1] = MAX(oboxlo[1],lo1[1]);
+            sbox[2] = MAX(oboxlo[2],lo1[2]);
+            sbox[3] = MIN(oboxhi[0],hi1[0]);
+            sbox[4] = MIN(oboxhi[1],hi1[1]);
+            sbox[5] = MIN(oboxhi[2],hi1[2]);
+          } else {
+            pbc_flag[iswap][i] = 1;
+            if (idir == 0) pbc[iswap][i][idim] = 1;
+            else pbc[iswap][i][idim] = -1;
+            if (triclinic) {
+              if (idim == 1) pbc[iswap][i][5] = pbc[iswap][i][idim];
+              if (idim == 2) pbc[iswap][i][4] = pbc[iswap][i][3] = pbc[iswap][i][idim];
+            }
+            sbox[0] = MAX(oboxlo[0],lo2[0]);
+            sbox[1] = MAX(oboxlo[1],lo2[1]);
+            sbox[2] = MAX(oboxlo[2],lo2[2]);
+            sbox[3] = MIN(oboxhi[0],hi2[0]);
+            sbox[4] = MIN(oboxhi[1],hi2[1]);
+            sbox[5] = MIN(oboxhi[2],hi2[2]);
+          }
+
+          for (int itype = 1; itype <= atom->ntypes; itype++) {
+            sbox_multiold[0] = sbox[0];
+            sbox_multiold[1] = sbox[1];
+            sbox_multiold[2] = sbox[2];
+            sbox_multiold[3] = sbox[3];
+            sbox_multiold[4] = sbox[4];
+            sbox_multiold[5] = sbox[5];
+            if (idir == 0) {
+              sbox_multiold[idim] = sublo[idim];
+              if (i < noverlap1)
+                sbox_multiold[3+idim] =
+                  MIN(sbox_multiold[3+idim]+cutghostmultiold[itype][idim],subhi[idim]);
+              else
+                sbox_multiold[3+idim] =
+                  MIN(sbox_multiold[3+idim]-prd[idim]+cutghostmultiold[itype][idim],subhi[idim]);
+            } else {
+              if (i < noverlap1)
+                sbox_multiold[idim] =
+                  MAX(sbox_multiold[idim]-cutghostmultiold[itype][idim],sublo[idim]);
+              else
+                sbox_multiold[idim] =
+                  MAX(sbox_multiold[idim]+prd[idim]-cutghostmultiold[itype][idim],sublo[idim]);
+              sbox_multiold[3+idim] = subhi[idim];
+            }
+
+            if (idim >= 1) {
+              if (sbox_multiold[0] == oboxlo[0])
+                sbox_multiold[0] -= cutghostmultiold[itype][idim];
+              if (sbox_multiold[3] == oboxhi[0])
+                sbox_multiold[3] += cutghostmultiold[itype][idim];
+            }
+            if (idim == 2) {
+              if (sbox_multiold[1] == oboxlo[1])
+                sbox_multiold[1] -= cutghostmultiold[itype][idim];
+              if (sbox_multiold[4] == oboxhi[1])
+                sbox_multiold[4] += cutghostmultiold[itype][idim];
+            }
+
+            memcpy(sendbox_multiold[iswap][i][itype],sbox_multiold,6*sizeof(double));
+          }
+        }
+      }
+
+      iswap++;
+    }
+  }
+
+
+  // setup exchange communication = subset of forward/reverse comm procs
+  // loop over dimensions
+  // determine which procs I will exchange with in each dimension
+  // subset of procs that touch my proc in forward/reverse comm
+  // sets nexchproc & exchproc, resets nexchprocmax
+
+  int proc;
+
+  for (int idim = 0; idim < dimension; idim++) {
+
+    // overlap = list of procs that touch my sub-box in idim
+    // proc can appear twice in list if touches in both directions
+    // 2nd add-to-list checks to ensure each proc appears exactly once
+
+    noverlap = 0;
+    iswap = 2*idim;
+    n = nsendproc[iswap];
+    for (i = 0; i < n; i++) {
+      proc = sendproc[iswap][i];
+      if (proc == me) continue;
+      if ((this->*box_touch)(proc,idim,0)) {
+        if (noverlap == maxoverlap) {
+          maxoverlap += DELTA_PROCS;
+          memory->grow(overlap,maxoverlap,"comm:overlap");
+        }
+        overlap[noverlap++] = proc;
+      }
+    }
+    noverlap1 = noverlap;
+    iswap = 2*idim+1;
+    n = nsendproc[iswap];
+
+    MPI_Barrier(world);
+
+    for (i = 0; i < n; i++) {
+      proc = sendproc[iswap][i];
+      if (proc == me) continue;
+      if ((this->*box_touch)(proc,idim,1)) {
+        for (j = 0; j < noverlap1; j++)
+          if (overlap[j] == proc) break;
+        if (j < noverlap1) continue;
+        if (noverlap == maxoverlap) {
+          maxoverlap += DELTA_PROCS;
+          memory->grow(overlap,maxoverlap,"comm:overlap");
+        }
+        overlap[noverlap++] = proc;
+      }
+    }
+
+    MPI_Barrier(world);
+
+    // reallocate exchproc and exchnum if needed based on noverlap
+
+    if (noverlap > nexchprocmax[idim]) {
+      while (nexchprocmax[idim] < noverlap) nexchprocmax[idim] += DELTA_PROCS;
+      delete [] exchproc[idim];
+      exchproc[idim] = new int[nexchprocmax[idim]];
+      delete [] exchnum[idim];
+      exchnum[idim] = new int[nexchprocmax[idim]];
+    }
+
+    nexchproc[idim] = noverlap;
+    for (i = 0; i < noverlap; i++) exchproc[idim][i] = overlap[i];
+  }
+
+  // reset sendproc/etc to 0 if cut is really 0.0
+
+  if (cutzero) {
+    for (i = 0; i < nswap; i++) {
+      nsendproc[i] = nrecvproc[i] =
+        sendother[i] = recvother[i] = sendself[i] = 0;
+    }
+  }
+
+  // reallocate MPI Requests as needed
+
+  int nmax = 0;
+  for (i = 0; i < nswap; i++) nmax = MAX(nmax,nprocmax[i]);
+  for (i = 0; i < dimension; i++) nmax = MAX(nmax,nexchprocmax[i]);
+  if (nmax > maxrequest) {
+    maxrequest = nmax;
+    delete [] requests;
+    requests = new MPI_Request[maxrequest];
+  }
+}
+
+/**
+  * exchange: move atoms to correct processors
+  * atoms exchanged with procs that touch sub-box in each of 3 dims
+  * send out atoms that have left my box, receive ones entering my box
+  * atoms will be lost if not inside a touching proc's box
+  *   can happen if atom moves outside of non-periodic boundary
+  *   or if atom moves more than one proc away
+  * this routine called before every reneighboring
+  * for triclinic, atoms must be in lamda coords (0-1) before exchange is called
+  */
+
+void CommStaggered::exchange()
+{
+  if (layout != Comm::LAYOUT_STAGGERED) {
+    CommTiled::exchange();
+    return;
+  }
+  int i,m,nexch,nsend,nrecv,nlocal,proc,offset;
+  double lo,hi,value;
+  double **x;
+  AtomVec *avec = atom->avec;
+
+  // clear global->local map for owned and ghost atoms
+  // b/c atoms migrate to new procs in exchange() and
+  //   new ghosts are created in borders()
+  // map_set() is done at end of borders()
+  // clear ghost count and any ghost bonus data internal to AtomVec
+
+  if (map_style != Atom::MAP_NONE) atom->map_clear();
+  atom->nghost = 0;
+  atom->avec->clear_bonus();
+
+  // ensure send buf has extra space for a single atom
+  // only need to reset if a fix can dynamically add to size of single atom
+
+  if (maxexchange_fix_dynamic) {
+    init_exchange();
+    if (bufextra > bufextra_max) {
+      grow_send(maxsend+bufextra,2);
+      bufextra = bufextra_max;
+    }
+  }
+
+  // domain properties used in exchange method and methods it calls
+  // subbox bounds for orthogonal or triclinic
+
+  if (triclinic == 0) {
+    prd = domain->prd;
+    boxlo = domain->boxlo;
+    boxhi = domain->boxhi;
+    sublo = domain->sublo;
+    subhi = domain->subhi;
+  } else {
+    prd = domain->prd_lamda;
+    boxlo = domain->boxlo_lamda;
+    boxhi = domain->boxhi_lamda;
+    sublo = domain->sublo_lamda;
+    subhi = domain->subhi_lamda;
+  }
+
+  // loop over dimensions
+
+  dimension = domain->dimension;
+
+  ///> @todo-optimize
+  ///>       Loop over dimensions starting with layers for comm_style = staggered?
+  ///>       Could cause bugs for brick functions.
+  for (int dim = 0; dim < dimension; dim++) {
+
+    // fill buffer with atoms leaving my box, using < and >=
+    // when atom is deleted, fill it in with last atom
+
+    x = atom->x;
+    lo = sublo[dim];
+    hi = subhi[dim];
+    nlocal = atom->nlocal;
+    i = nsend = 0;
+
+    while (i < nlocal) {
+      if (x[i][dim] < lo || x[i][dim] >= hi) {
+        if (nsend > maxsend) grow_send(nsend,1);
+        proc = (this->*point_drop)(dim,x[i]);
+        if (proc != me) {
+          buf_send[nsend++] = proc;
+          nsend += avec->pack_exchange(i,&buf_send[nsend]);
+        } else {
+          // DEBUG statment
+          // error->warning(FLERR,"Losing atom in CommStaggered::exchange() send, "
+          //               "likely bad dynamics");
+        }
+        avec->copy(nlocal-1,i,1);
+        nlocal--;
+      } else i++;
+    }
+    atom->nlocal = nlocal;
+
+    // send and recv atoms from neighbor procs that touch my sub-box in dim
+    // no send/recv with self
+    // send size of message first
+    // receiver may receive multiple messages, realloc buf_recv if needed
+
+    nexch = nexchproc[dim];
+    if (!nexch) continue;
+
+    for (m = 0; m < nexch; m++) {
+      MPI_Irecv(&exchnum[dim][m],1,MPI_INT,exchproc[dim][m],2*dim,world,&requests[m]);
+    }
+    for (m = 0; m < nexch; m++) {
+      MPI_Send(&nsend,1,MPI_INT,exchproc[dim][m],2*dim,world);
+    }
+    MPI_Waitall(nexch,requests,MPI_STATUS_IGNORE);
+
+    nrecv = 0;
+    for (m = 0; m < nexch; m++) nrecv += exchnum[dim][m];
+    if (nrecv > maxrecv) grow_recv(nrecv);
+
+    offset = 0;
+    for (m = 0; m < nexch; m++) {
+      MPI_Irecv(&buf_recv[offset],exchnum[dim][m],MPI_DOUBLE,exchproc[dim][m],2*dim+1,world,&requests[m]); ///>@debug count may be zero
+      offset += exchnum[dim][m];
+    }
+    for (m = 0; m < nexch; m++) {
+      MPI_Send(buf_send,nsend,MPI_DOUBLE,exchproc[dim][m],2*dim+1,world); ///>@debug count may be zero
+    }
+    MPI_Waitall(nexch,requests,MPI_STATUS_IGNORE);
+
+    // check incoming atoms to see if I own it and they are in my box
+    // if so, add to my list
+    // box check is only for this dimension,
+    //   atom may be passed to another proc in later dims
+
+    m = 0;
+    while (m < nrecv) {
+      proc = static_cast<int> (buf_recv[m++]);
+      if (proc == me) {
+        value = buf_recv[m+dim+1];
+        if (value >= lo && value < hi) {
+          m += avec->unpack_exchange(&buf_recv[m]);
+          continue;
+        } else {
+          // DEBUG statment
+          // error->warning(FLERR,"Losing atom in CommStaggered::exchange() recv");
+        }
+      }
+      m += static_cast<int> (buf_recv[m]);
+    }
+  }
+
+  if (atom->firstgroupname) atom->first_reorder();
+}
+
+/**
+  * Determine overlap list of Noverlap procs the lo/hi box overlaps.
+  * overlap = non-zero area in common between box and proc sub-domain.
+  * Recursive method for traversing an RCB tree of cuts.
+  * No need to split lo/hi box as recurse b/c OK if box extends outside RCB box.
+  * @todo-optimize
+  *       Rewrite and consider the fact, that the requested neighbours are in neighbouring layers, rows, cells
+  * @param[in] lo left box boundaries in spatial box coordinates
+  * @param[in] hi right box boundaries in spatial box coordinates
+  * @note Writes overlaping processors to array overlap.
+  *       The number of processors in this array is noverlap.
+  * @param[out] indexme index of own processor in overlap list
+  */
+
+void CommStaggered::box_drop_staggered(int /*idim*/, double *lo, double *hi, int &indexme)
+{
+  int layer_lo, layer_hi, layer_i;
+  int row_lo, row_hi, row_i;
+  int cell_lo, cell_hi, cell_i;
+  int rank_overlap;
+
+  // calculate layer range
+  box_drop_1d(lo[staggered2spatial[0]], hi[staggered2spatial[0]], layer_splits, n_layers,
+             staggered2spatial[0], layer_lo, layer_hi);
+  for (int i_layer=layer_lo; i_layer<=layer_hi; i_layer++) {
+    // calculate row range
+    box_drop_1d(lo[staggered2spatial[1]], hi[staggered2spatial[1]], row_splits[i_layer], n_rows,
+                staggered2spatial[1], row_lo, row_hi);
+
+    for (int i_row=row_lo; i_row<=row_hi; i_row++) {
+      // calculate cell range
+      box_drop_1d(lo[staggered2spatial[2]], hi[staggered2spatial[2]], cell_splits[i_layer][i_row],
+                  n_cells, staggered2spatial[2], cell_lo, cell_hi);
+
+      for (int i_cell=cell_lo; i_cell<=cell_hi; i_cell++) {
+        // this cell overlaps with the given box
+        rank_overlap = staggered_grid2proc[i_layer][i_row][i_cell];
+
+        // allocate more memory if required
+        if (noverlap == maxoverlap) {
+          maxoverlap += DELTA_PROCS;
+          memory->grow(overlap,maxoverlap,"comm:overlap");
+        }
+
+        if (rank_overlap == me) indexme = noverlap;
+        overlap[noverlap++] = rank_overlap;
+      }
+    }
+  }
+}
+
+/**
+  * @brief return other box owned by proc as lo/hi corner pts
+  * @param[in] proc rank of a processor
+  * @param[out] lo low boundaries of processor in box units
+  * @param[out] hi high boundaries of processor in box units
+  */
+
+void CommStaggered::box_other_staggered(int /*idim*/, int /*idir*/, int proc, double *lo, double *hi)
+{
+  int * loc = staggered_proc2grid[proc];
+
+  lo[staggered2spatial[0]] = boxlo[staggered2spatial[0]] + prd[staggered2spatial[0]]*layer_splits[loc[0]];
+  if (loc[0]+1 == n_layers) hi[staggered2spatial[0]] = boxhi[staggered2spatial[0]];
+  else hi[staggered2spatial[0]] = boxlo[staggered2spatial[0]] + prd[staggered2spatial[0]]*layer_splits[loc[0]+1];
+
+  lo[staggered2spatial[1]] = boxlo[staggered2spatial[1]] + prd[staggered2spatial[1]]*row_splits[loc[0]][loc[1]];
+  if (loc[1]+1 == n_rows) hi[staggered2spatial[1]] = boxhi[staggered2spatial[1]];
+  else hi[staggered2spatial[1]] = boxlo[staggered2spatial[1]] + prd[staggered2spatial[1]]*row_splits[loc[0]][loc[1]+1];
+
+  lo[staggered2spatial[2]] = boxlo[staggered2spatial[2]] + prd[staggered2spatial[2]]*cell_splits[loc[0]][loc[1]][loc[2]];
+  if (loc[2]+1 == n_cells) hi[staggered2spatial[2]] = boxhi[staggered2spatial[2]];
+  else hi[staggered2spatial[2]] = boxlo[staggered2spatial[2]] + prd[staggered2spatial[2]]*cell_splits[loc[0]][loc[1]][loc[2]+1];
+
+}
+
+/**
+  * @brief return other box owned by proc as lo/hi corner pts
+  * @param[in] proc rank of a processor
+  * @param[out] lo low boundaries of processor in [0,1] units
+  * @param[out] hi high boundaries of processor in [0,1] units
+  */
+
+void CommStaggered::box_other_mysplit(int proc, double *lo, double *hi)
+{
+  int * loc = staggered_proc2grid[proc];
+
+  lo[staggered2spatial[0]] = layer_splits[loc[0]];
+  hi[staggered2spatial[0]] = layer_splits[loc[0]+1];
+
+  lo[staggered2spatial[1]] = row_splits[loc[0]][loc[1]];
+  hi[staggered2spatial[1]] = row_splits[loc[0]][loc[1]+1];
+
+  lo[staggered2spatial[2]] = cell_splits[loc[0]][loc[1]][loc[2]];
+  hi[staggered2spatial[2]] = cell_splits[loc[0]][loc[1]][loc[2]+1];
+}
+
+/**
+  * return 1 if proc's box touches me, else 0
+  * @param[in] proc other processor
+  * @param[in] idim dimension in which the touch is tested
+  * @param[in] idir direction in which the touch is tested (0 = left of my processor, 1 = right)
+  * @return 1 if neighbous in idim and idir, 0 otherwise
+  */
+
+int CommStaggered::box_touch_staggered(int proc, int idim, int idir)
+{
+  // use staggered grid notation
+  idim = spatial2staggered[idim];
+
+  // sending to left
+  // only touches if proc hi = my lo, or if proc hi = boxhi and my lo = boxlo
+
+  if (idir == 0) {
+    if (staggered_proc2grid[proc][idim] + 1 == staggered_myloc[idim])
+      return 1;
+    else if (staggered_proc2grid[proc][idim] == staggered_procgrid[idim] - 1 &&
+             staggered_myloc[idim] == 0)
+      return 1;
+
+  // sending to right
+  // only touches if proc lo = my hi, or if proc lo = boxlo and my hi = boxhi
+
+  } else {
+    if (staggered_proc2grid[proc][idim] == staggered_myloc[idim] + 1)
+      return 1;
+    else if (staggered_proc2grid[proc][idim] == 0 &&
+             staggered_myloc[idim] == staggered_procgrid[idim] -1)
+      return 1;
+  }
+
+  return 0;
+}
+
+/**
+  * @brief Determine which proc owns point x.
+  * Drop point into staggered mesh.
+  * Sending starts with increasing idim.
+  * Smaller dimensions that idim are already exchanged.
+  * @todo-optimize
+  *       Rewrite function since it depends on the tiled communication routine.
+  *       When starting with communictation in layer direction, on can simply
+  *       check only the neighbouring layer and so on.
+  * @param[in] idim dimension in which the point is outside
+  * @param[in] x position of point
+  */
+
+int CommStaggered::point_drop_staggered(int idim, double *x)
+{
+  double xnew[3];
+  xnew[0] = x[0]; xnew[1] = x[1]; xnew[2] = x[2];
+
+  // Ensure that the target processor is a neighbour.
+  // idim = 0
+  // Set xnew to own boundaries if x is outside in dimensions 1 and 2.
+  // idim = 1
+  // Set xnew to own boundaries if x is outside in dimensions 2.
+  // idim = 2
+  // Do not change xnew.
+
+
+  if (idim == 0) {
+    if (xnew[1] < sublo[1] || xnew[1] > subhi[1]) {
+      if (closer_subbox_edge(1,x)) xnew[1] = subhi[1];
+      else xnew[1] = sublo[1];
+    }
+  }
+  if (idim <= 1) {
+    if (xnew[2] < sublo[2] || xnew[2] > subhi[2]) {
+      if (closer_subbox_edge(2,x)) xnew[2] = subhi[2];
+      else xnew[2] = sublo[2];
+    }
+  }
+
+  int proc = point_drop_staggered_recurse(xnew);
+  double proc_lo[3], proc_hi[3];
+  if (proc == me) return me;
+
+  // x communication
+  if (idim == 0) {
+    box_other_mysplit(proc, proc_lo, proc_hi);
+
+    int done = 1;
+    //  proc y lo == me y hi
+    if (proc_lo[1] == mysplit[1][1]) {
+      // proc is right of me in y
+      xnew[1] -= EPSILON * (subhi[1]-sublo[1]);
+      // move atom inside of own proc
+      // -> atom is not send to this neighbour (in this step)
+      // atom could be sent in y communication
+      done = 0;
+      // -> drop point again to find different processor
+    }
+    if (proc_lo[2] == mysplit[2][1]) {
+      // proc is right of me in z
+      xnew[2] -= EPSILON * (subhi[2]-sublo[2]);
+      // change xnew to inside in z
+      done = 0;
+      // -> drop point again
+    }
+    if (!done) {
+      proc = point_drop_staggered_recurse(xnew);
+      box_other_mysplit(proc, proc_lo, proc_hi);
+      done = 1;
+      // proc y lo == me y hi
+      // -> proc is right of me in y
+      if (proc_lo[1] == mysplit[1][1]) {
+        // set atom inside in y
+        xnew[1] -= EPSILON * (subhi[1]-sublo[1]);
+        // drop again
+        done = 0;
+      }
+      // proc z lo == me z hi
+      // -> proc is right of me in z
+      if (proc_lo[2] == mysplit[2][1]) {
+        // set atom inside in z
+        xnew[2] -= EPSILON * (subhi[2]-sublo[2]);
+        // drop again
+        done = 0;
+      }
+      if (!done) proc = point_drop_staggered_recurse(xnew);
+      ///> ->The atom is shifted inside of the own box in y and z if required to find a neighbour in x direction
+    }
+  } else if (idim == 1) {
+    // proc z lo == me z hi
+    // -> proc is right of me in z
+    box_other_mysplit(proc, proc_lo, proc_hi);
+    if (proc_lo[2] == mysplit[2][1]) {
+      xnew[2] -= EPSILON * (subhi[2]-sublo[2]);
+      proc = point_drop_staggered_recurse(xnew);
+    }
+  }
+
+  return proc;
+}
+
+/**
+  * @brief Drop point in staggered mesh in dimension dim.
+  * @note Do not use for box drop since the boundary conditions differ.
+  *       A point is inside for p in [splitlo, splithi).
+  *       A box point is inside for p in (splitlo, splithi).
+  * @param[in] value to sort into staggered mesh in box coordinatos
+  * @param[in] splitlist list of splits e.g. layer_splits
+  * @param[in] listlen length of splitlist
+  * @param[in] dim spatial dimension of value
+  * @return i in staggered grid in the given dimension
+  */
+
+int CommStaggered::point_drop_1d(double value, double * splitlist, int listlen, int dim)
+{
+  double cut;
+  int procmid;
+
+  int proclower = 0;
+  int procupper = listlen -1;
+  while (proclower != procupper) {
+    procmid = proclower + (procupper - proclower) / 2 + 1;
+    cut = boxlo[dim] + prd[dim] * splitlist[procmid];
+    if (value < cut) procupper = procmid -1;
+    else proclower = procmid;
+  }
+  return proclower;
+}
+
+/**
+  * @brief Drop 1d box in staggered mesh in dimension dim.
+  * @note Do not use for point drop since the boundary conditions differ.
+  *       A point is inside for p in [splitlo, splithi).
+  *       A box point is inside for p in (splitlo, splithi).
+  * @param[in] lo lower value to sort into staggered mesh in box coordinatos
+  * @param[in] hi lower value to sort into staggered mesh in box coordinatos
+  * @param[in] splitlist list of splits e.g. layer_splits
+  * @param[in] listlen length of splitlist
+  * @param[in] dim spatial dimension of value
+  * @param[out] rtn_lo processor i in staggered grid in the given dimension of value lo
+  * @param[out] rtn_hi processor i in staggered grid in the given dimension of value hi
+  */
+
+void CommStaggered::box_drop_1d(double lo, double hi, double * splitlist, int listlen, int dim, int & rtn_lo, int & rtn_hi)
+{
+  double cut;
+  int procmid, proclower, procupper;
+
+  // drop lo
+  proclower = 0;
+  procupper = listlen -1;
+  while (proclower != procupper) {
+    procmid = proclower + (procupper - proclower) / 2 + 1;
+    cut = boxlo[dim] + prd[dim] * splitlist[procmid];
+    if (lo < cut) procupper = procmid -1;
+    else proclower = procmid;
+  }
+  rtn_lo = proclower;
+
+  // drop hi
+  // hi > lo -> rtn_hi >= rtn_lo
+  procupper = listlen -1;
+  while (proclower != procupper) {
+    procmid = proclower + (procupper - proclower) / 2 + 1;
+    cut = boxlo[dim] + prd[dim] * splitlist[procmid];
+    if (hi > cut ) proclower = procmid;
+    else procupper = procmid -1;
+  }
+  rtn_hi = proclower;
+}
+
+/**
+  * drop in staggered mesh
+  * @param[in] x point in box coordinates
+  * @return rank of processor
+  */
+
+int CommStaggered::point_drop_staggered_recurse(double *x)
+{
+  int i_layer, i_row, i_cell;
+  // find layer
+  i_layer = point_drop_1d(x[staggered2spatial[0]], layer_splits,                n_layers, staggered2spatial[0]);
+  i_row   = point_drop_1d(x[staggered2spatial[1]], row_splits[i_layer],         n_rows,   staggered2spatial[1]);
+  i_cell  = point_drop_1d(x[staggered2spatial[2]], cell_splits[i_layer][i_row], n_cells,  staggered2spatial[2]);
+
+  return staggered_grid2proc[i_layer][i_row][i_cell];
+}
+
+/**
+  * probably wrong line: if RCB decomp exists and just changed, gather needed global RCB info
+  *
+  * required input: procgrid, myloc, spatial2staggered, staggered2spatial, grid2proc
+  */
+
+void CommStaggered::coord2proc_setup()
+{
+  if (!staggerednew) return;
+  staggerednew = 0;
+
+  // gather lower boundaries of all processors
+  double gatherbuffer[nprocs*3];
+  gatherbuffer[me*3+spatial2staggered[0]] = mysplit[0][0];
+  gatherbuffer[me*3+spatial2staggered[1]] = mysplit[1][0];
+  gatherbuffer[me*3+spatial2staggered[2]] = mysplit[2][0];
+  MPI_Allgather(MPI_IN_PLACE,3,MPI_DOUBLE,gatherbuffer,3,MPI_DOUBLE,world);
+
+  // store splits
+  for (int il = 0; il < n_layers; il++) {
+    layer_splits[il] = gatherbuffer[staggered_grid2proc[il][0][0]*3+0];
+    for (int ir = 0; ir < n_rows; ir++) {
+      row_splits[il][ir] = gatherbuffer[staggered_grid2proc[il][ir][0]*3+1];
+      for (int ic = 0; ic < n_cells; ic++) {
+        cell_splits[il][ir][ic] = gatherbuffer[staggered_grid2proc[il][ir][ic]*3+2];
+      }
+      cell_splits[il][ir][n_cells] = 1;
+    }
+    row_splits[il][n_rows] = 1;
+  }
+  layer_splits[n_layers] = 1;
+}
+
+/**
+  * Determine which proc owns atom with coord x[3] based on current decomp.
+  * x will be in box (orthogonal) or lamda coords (triclinic).
+  * if layout = UNIFORM or NONUNIFORM, invoke parent method.
+  * if layout = STAGGERED, use point_drop_recurse().
+  * @return owning proc ID, ignore igx,igy,igz
+  */
+
+int CommStaggered::coord2proc(double *x, int &igx, int &igy, int &igz)
+{
+  if (layout != Comm::LAYOUT_STAGGERED) return Comm::coord2proc(x,igx,igy,igz);
+  return point_drop_staggered_recurse(x);
+}
+
+/* ----------------------------------------------------------------------
+   return # of bytes of allocated memory
+------------------------------------------------------------------------- */
+
+double CommStaggered::memory_usage()
+{
+  double bytes = 0;
+  return bytes;
+}
diff -ruN a/src/comm_staggered.h b/src/comm_staggered.h
--- a/src/comm_staggered.h	1970-01-01 01:00:00.000000000 +0100
+++ b/src/comm_staggered.h	2025-11-05 16:36:36.441510411 +0100
@@ -0,0 +1,68 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifndef LMP_COMM_STAGGERED_H
+#define LMP_COMM_STAGGERED_H
+
+#include "comm.h"
+#include "comm_tiled.h"
+
+namespace LAMMPS_NS {
+
+class CommStaggered : public CommTiled {
+ public:
+  CommStaggered(class LAMMPS *, class Comm *, char * arg);
+
+  ~CommStaggered() override;
+
+  void setup() override;                // setup comm pattern
+  void exchange() override;             // move atoms to new procs
+
+  void coord2proc_setup() override;
+  int coord2proc(double *, int &, int &, int &) override;
+
+  double memory_usage() override;
+
+ private:
+  double * layer_splits;                // store splits for layers
+  double ** row_splits;                 // store splits for rows
+  double *** cell_splits;               // store splits for cells
+
+  void init_buffers_staggered();
+
+  // box drop and other functions
+  void box_drop_1d(double, double, double *, int , int , int &, int &);
+  int point_drop_1d(double, double *, int, int);
+
+  typedef void (CommStaggered::*BoxDropPtr)(int, double *, double *, int &);
+  BoxDropPtr box_drop;
+  void box_drop_staggered(int, double *, double *, int &);
+
+  typedef void (CommStaggered::*BoxOtherPtr)(int, int, int, double *, double *);
+  BoxOtherPtr box_other;
+  void box_other_staggered(int, int, int, double *, double *);
+  void box_other_mysplit(int, double *, double *);
+
+  typedef int (CommStaggered::*BoxTouchPtr)(int, int, int);
+  BoxTouchPtr box_touch;
+  int box_touch_staggered(int, int, int);
+
+  typedef int (CommStaggered::*PointDropPtr)(int, double *);
+  PointDropPtr point_drop;
+  int point_drop_staggered(int, double *);
+  int point_drop_staggered_recurse(double *);
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
diff -ruN a/src/domain.cpp b/src/domain.cpp
--- a/src/domain.cpp	2025-11-05 15:55:23.255725975 +0100
+++ b/src/domain.cpp	2025-11-05 16:36:36.442771195 +0100
@@ -324,7 +324,7 @@
 
 void Domain::set_lamda_box()
 {
-  if (comm->layout != Comm::LAYOUT_TILED) {
+  if (comm->layout != Comm::LAYOUT_TILED && comm->layout != Comm::LAYOUT_STAGGERED) {
     int *myloc = comm->myloc;
     double *xsplit = comm->xsplit;
     double *ysplit = comm->ysplit;
@@ -361,7 +361,7 @@
 {
   if (triclinic) return;
 
-  if (comm->layout != Comm::LAYOUT_TILED) {
+  if (comm->layout != Comm::LAYOUT_TILED && comm->layout != Comm::LAYOUT_STAGGERED) {
     int *myloc = comm->myloc;
     int *procgrid = comm->procgrid;
     double *xsplit = comm->xsplit;
diff -ruN a/src/input.cpp b/src/input.cpp
--- a/src/input.cpp	2025-11-05 15:55:23.032701000 +0100
+++ b/src/input.cpp	2025-11-05 16:36:36.444204000 +0100
@@ -21,6 +21,7 @@
 #include "bond.h"
 #include "comm.h"
 #include "comm_brick.h"
+#include "comm_staggered.h"
 #include "comm_tiled.h"
 #include "command.h"
 #include "compute.h"
@@ -1455,6 +1456,12 @@
     if (lmp->kokkos) comm = new CommTiledKokkos(lmp,oldcomm);
     else comm = new CommTiled(lmp,oldcomm);
     delete oldcomm;
+  } else if (strcmp(arg[0],"staggered") == 0) {
+    if (narg < 2) error->all(FLERR,"Illegal comm_style staggered command");
+    Comm *oldcomm = comm;
+    if (lmp->kokkos) error->all(FLERR,"kokkos is not supported by CommStaggered");
+    else comm = new CommStaggered(lmp, oldcomm, arg[1]);
+    delete oldcomm;
   } else error->all(FLERR,"Unknown comm_style argument: {}", arg[0]);
 }
 
diff -ruN a/src/irregular.cpp b/src/irregular.cpp
--- a/src/irregular.cpp	2025-11-05 15:55:23.035561000 +0100
+++ b/src/irregular.cpp	2025-11-05 16:36:36.445521000 +0100
@@ -226,10 +226,11 @@
 
 int Irregular::migrate_check()
 {
-  // migrate required if comm layout is tiled
+  // migrate required if comm layout is tiled or staggered
   // cannot use myloc[] logic below
 
   if (comm->layout == Comm::LAYOUT_TILED) return 1;
+  if (comm->layout == Comm::LAYOUT_STAGGERED) return 1;
 
   // subbox bounds for orthogonal or triclinic box
 
diff -ruN a/src/library.cpp b/src/library.cpp
--- a/src/library.cpp	2025-11-05 15:55:27.824695385 +0100
+++ b/src/library.cpp	2025-11-05 16:36:36.447550920 +0100
@@ -1412,9 +1412,9 @@
    * - world_size
      - Number of ranks on LAMMPS' world communicator (aka comm->nprocs)
    * - comm_style
-     - communication style (0 = BRICK, 1 = TILED)
+     - communication style (0 = BRICK, 1 = TILED, 2 = STAGGERED)
    * - comm_layout
-     - communication layout (0 = LAYOUT_UNIFORM, 1 = LAYOUT_NONUNIFORM, 2 = LAYOUT_TILED)
+     - communication layout (0 = LAYOUT_UNIFORM, 1 = LAYOUT_NONUNIFORM, 2 = LAYOUT_TILED, 3 = LAYOUT_STAGGERED)
    * - comm_mode
      - communication mode (0 = SINGLE, 1 = MULTI, 2 = MULTIOLD)
    * - ghost_velocity
diff -ruN a/src/Makefile b/src/Makefile
--- a/src/Makefile	2025-11-05 15:55:20.324259000 +0100
+++ b/src/Makefile	2025-11-05 16:36:36.449395000 +0100
@@ -52,6 +52,7 @@
 	molecule \
 	kspace \
 	adios \
+	allpkg \
 	amoeba \
 	apip \
 	asphere \
@@ -238,6 +239,7 @@
 	ml-quip \
 	rheo \
 	scafacos \
+	allpkg \
 	machdyn \
 	vtk \
 	electrode
@@ -248,6 +250,7 @@
 
 PACKEXT = \
 	adios \
+	allpkg \
 	apip \
 	h5md \
 	kim \
